// Generated by the WOLips TemplateEngine Plug-in at Mar 3, 2005 1:19:55 PM

package com.gvcsitemaker.utility.conversion;
import com.gvcsitemaker.core.*;

import com.webobjects.appserver.*;
import com.webobjects.eocontrol.*;
import com.webobjects.foundation.*;

import net.global_village.eofvalidation.EOEditingContext;


/**
 * During the conversion to GVC.SM3.5, Single Link or File (aka External URL), Embedded Site and Embedded 
 * Section sections were left with access groups other than Everyone.  While these are not used, they 
 * are misleading.  In 3.5 there is no way for the user ot edit them. These groups should be removed 
 * and replaced with Everyone.
 *
// Copyright (c) 2001-2005, The Regents of the University of Michigan, Ann Arbor, MI 48109 USA   All rights reserved.
// This software is published under the terms of the Educational Community License (ECL) version 1.0,
// a copy of which has been included with this distribution in the LICENSE.TXT file.
 */
public class RemoveObsoleteAccessGroups extends WOComponent {

    public String cleanupMessage = "";
    
    public RemoveObsoleteAccessGroups(WOContext context) {
        super(context);
    }


    public WOComponent cleanup() {
        EOEditingContext ec = new EOEditingContext();
        ec.lock();
        try
        {
            cleanup(EmbeddedSiteSectionType.getInstance(ec));
            cleanup(EmbeddedSectionSectionType.getInstance(ec));
            cleanup(ExternalURLSectionType.getInstance(ec));
        }
        finally
        {
            ec.unlock();
            ec.dispose();
        }

        return context().page();
    }  
    
    
    public  void cleanup(SectionType type) {
    EOEditingContext ec = (EOEditingContext) type.editingContext();
    Group publicGroup = PublicGroup.group(ec);
    
    EOQualifier sectionsOfType = EOQualifier.qualifierWithQualifierFormat("type = %@", new NSArray(type));
    EOFetchSpecification fetchSpec = new EOFetchSpecification("Section", sectionsOfType, null);
    NSArray affectedSections = ec.objectsWithFetchSpecification(fetchSpec); 
    NSLog.out.appendln("Fetched " + affectedSections.count() + " sections of type " + type.getClass());
    int affectedSectionsCount = 0;
    for (int i = 0; i < affectedSections.count(); i++)
    {
        Section aSection = (Section) affectedSections.objectAtIndex(i);
        NSLog.out.appendln("Fixing section " + aSection);
        if ((aSection.groups().count() != 1) || ( ! (aSection.groups().objectAtIndex(0) instanceof PublicGroup)))
        {
            NSLog.out.appendln("Fixing section " + aSection.name() + " of site " + aSection.website().siteID());
            
            // Do it forcefully to avoid validation problems with invalid LDAP group names
            aSection.setGroups(new NSMutableArray(publicGroup));
            affectedSectionsCount++;
            
            if ((aSection.groups().count() != 1) || ( ! (aSection.groups().objectAtIndex(0) instanceof PublicGroup)))
            {
                throw new RuntimeException("logic failure");
            }
        }
        ec.saveChanges();
    }

    NSLog.out.appendln("Cleaned up " + affectedSections.count() + " sections");
    cleanupMessage += "Cleaned up " + affectedSections.count() + " sections, ";
    }
    

    
}
