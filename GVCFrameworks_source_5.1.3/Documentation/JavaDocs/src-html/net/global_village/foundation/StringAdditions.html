<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    package net.global_village.foundation;<a name="line.1"></a>
<FONT color="green">002</FONT>    <a name="line.2"></a>
<FONT color="green">003</FONT>    import java.math.*;<a name="line.3"></a>
<FONT color="green">004</FONT>    import java.util.*;<a name="line.4"></a>
<FONT color="green">005</FONT>    <a name="line.5"></a>
<FONT color="green">006</FONT>    import com.webobjects.foundation.*;<a name="line.6"></a>
<FONT color="green">007</FONT>    <a name="line.7"></a>
<FONT color="green">008</FONT>    <a name="line.8"></a>
<FONT color="green">009</FONT>    /**<a name="line.9"></a>
<FONT color="green">010</FONT>     * String utilities.<a name="line.10"></a>
<FONT color="green">011</FONT>     *<a name="line.11"></a>
<FONT color="green">012</FONT>     * @author Copyright (c) 2001-2005  Global Village Consulting, Inc.  All rights reserved.<a name="line.12"></a>
<FONT color="green">013</FONT>     * This software is published under the terms of the Educational Community License (ECL) version 1.0,<a name="line.13"></a>
<FONT color="green">014</FONT>     * a copy of which has been included with this distribution in the LICENSE.TXT file.<a name="line.14"></a>
<FONT color="green">015</FONT>     * @version $Revision: 13$<a name="line.15"></a>
<FONT color="green">016</FONT>     */<a name="line.16"></a>
<FONT color="green">017</FONT>    public class StringAdditions<a name="line.17"></a>
<FONT color="green">018</FONT>    {<a name="line.18"></a>
<FONT color="green">019</FONT>        public static final String PasswordCharacters = "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789";<a name="line.19"></a>
<FONT color="green">020</FONT>        protected static Random generator = new Random();<a name="line.20"></a>
<FONT color="green">021</FONT>    <a name="line.21"></a>
<FONT color="green">022</FONT>        /**<a name="line.22"></a>
<FONT color="green">023</FONT>         * Static methods only.  You'll never need to instantiate this class.<a name="line.23"></a>
<FONT color="green">024</FONT>         */<a name="line.24"></a>
<FONT color="green">025</FONT>        private StringAdditions()<a name="line.25"></a>
<FONT color="green">026</FONT>        {<a name="line.26"></a>
<FONT color="green">027</FONT>            super();<a name="line.27"></a>
<FONT color="green">028</FONT>        }<a name="line.28"></a>
<FONT color="green">029</FONT>    <a name="line.29"></a>
<FONT color="green">030</FONT>    <a name="line.30"></a>
<FONT color="green">031</FONT>    <a name="line.31"></a>
<FONT color="green">032</FONT>        /**<a name="line.32"></a>
<FONT color="green">033</FONT>         * Attempts to separate the key components of the given key path.  Right now, just uses the lame NSArray.componentsSeparatedByString, but if this ever doesn't cut it, this is the only method that need change.<a name="line.33"></a>
<FONT color="green">034</FONT>         *<a name="line.34"></a>
<FONT color="green">035</FONT>         * @param aString the key or key path to sepearate into components<a name="line.35"></a>
<FONT color="green">036</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;aString&lt;/code&gt; has two or more components separated by periods<a name="line.36"></a>
<FONT color="green">037</FONT>         */<a name="line.37"></a>
<FONT color="green">038</FONT>        public static NSArray keyPathComponents(String aString)<a name="line.38"></a>
<FONT color="green">039</FONT>        {<a name="line.39"></a>
<FONT color="green">040</FONT>            /** require [valid_param] aString != null; **/<a name="line.40"></a>
<FONT color="green">041</FONT>            return NSArray.componentsSeparatedByString(aString, ".");<a name="line.41"></a>
<FONT color="green">042</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.42"></a>
<FONT color="green">043</FONT>        }<a name="line.43"></a>
<FONT color="green">044</FONT>    <a name="line.44"></a>
<FONT color="green">045</FONT>    <a name="line.45"></a>
<FONT color="green">046</FONT>    <a name="line.46"></a>
<FONT color="green">047</FONT>        /**<a name="line.47"></a>
<FONT color="green">048</FONT>         * Given a string determines if it is a key path (two or more parts seperated by periods).<a name="line.48"></a>
<FONT color="green">049</FONT>         *<a name="line.49"></a>
<FONT color="green">050</FONT>         * @param aString a string to test<a name="line.50"></a>
<FONT color="green">051</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;aString&lt;/code&gt; has two or more components separated by periods<a name="line.51"></a>
<FONT color="green">052</FONT>         */<a name="line.52"></a>
<FONT color="green">053</FONT>        public static boolean isValidPropertyKeyPath(String aString)<a name="line.53"></a>
<FONT color="green">054</FONT>        {<a name="line.54"></a>
<FONT color="green">055</FONT>            /** require [valid_param] aString != null; **/<a name="line.55"></a>
<FONT color="green">056</FONT>    <a name="line.56"></a>
<FONT color="green">057</FONT>            return keyPathComponents(aString).count() &gt; 1;<a name="line.57"></a>
<FONT color="green">058</FONT>        }<a name="line.58"></a>
<FONT color="green">059</FONT>    <a name="line.59"></a>
<FONT color="green">060</FONT>    <a name="line.60"></a>
<FONT color="green">061</FONT>    <a name="line.61"></a>
<FONT color="green">062</FONT>        /**<a name="line.62"></a>
<FONT color="green">063</FONT>         * Given a key path like object.object.attribute returns the "attribute" part.<a name="line.63"></a>
<FONT color="green">064</FONT>         *<a name="line.64"></a>
<FONT color="green">065</FONT>         * @param aString the keypath<a name="line.65"></a>
<FONT color="green">066</FONT>         * @return the final component in a keypath<a name="line.66"></a>
<FONT color="green">067</FONT>         */<a name="line.67"></a>
<FONT color="green">068</FONT>        public static String propertyNameFromKeyPath(String aString)<a name="line.68"></a>
<FONT color="green">069</FONT>        {<a name="line.69"></a>
<FONT color="green">070</FONT>            /** require [valid_param] aString != null; [valid_keypath] isValidPropertyKeyPath(aString); **/<a name="line.70"></a>
<FONT color="green">071</FONT>    <a name="line.71"></a>
<FONT color="green">072</FONT>            return (String)keyPathComponents(aString).lastObject();<a name="line.72"></a>
<FONT color="green">073</FONT>    <a name="line.73"></a>
<FONT color="green">074</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.74"></a>
<FONT color="green">075</FONT>        }<a name="line.75"></a>
<FONT color="green">076</FONT>    <a name="line.76"></a>
<FONT color="green">077</FONT>    <a name="line.77"></a>
<FONT color="green">078</FONT>    <a name="line.78"></a>
<FONT color="green">079</FONT>        /**<a name="line.79"></a>
<FONT color="green">080</FONT>         * Given a key path like object1.object2.attribute returns the "object1.object2" part.<a name="line.80"></a>
<FONT color="green">081</FONT>         *<a name="line.81"></a>
<FONT color="green">082</FONT>         * @param aString the keypath<a name="line.82"></a>
<FONT color="green">083</FONT>         * @return everything in the keypath except the final component<a name="line.83"></a>
<FONT color="green">084</FONT>         */<a name="line.84"></a>
<FONT color="green">085</FONT>        public static String objectKeyPathFromKeyPath(String aString)<a name="line.85"></a>
<FONT color="green">086</FONT>        {<a name="line.86"></a>
<FONT color="green">087</FONT>            /** require [valid_param] aString != null; [valid_keypath] isValidPropertyKeyPath(aString); **/<a name="line.87"></a>
<FONT color="green">088</FONT>    <a name="line.88"></a>
<FONT color="green">089</FONT>            NSMutableArray components = new NSMutableArray(keyPathComponents(aString));<a name="line.89"></a>
<FONT color="green">090</FONT>            components.removeLastObject();<a name="line.90"></a>
<FONT color="green">091</FONT>            return components.componentsJoinedByString(".");<a name="line.91"></a>
<FONT color="green">092</FONT>    <a name="line.92"></a>
<FONT color="green">093</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.93"></a>
<FONT color="green">094</FONT>        }<a name="line.94"></a>
<FONT color="green">095</FONT>    <a name="line.95"></a>
<FONT color="green">096</FONT>    <a name="line.96"></a>
<FONT color="green">097</FONT>    <a name="line.97"></a>
<FONT color="green">098</FONT>        /**<a name="line.98"></a>
<FONT color="green">099</FONT>         * Given a key path like object1.object2.attribute returns the "object1" part.<a name="line.99"></a>
<FONT color="green">100</FONT>         *<a name="line.100"></a>
<FONT color="green">101</FONT>         * @param aString the keypath<a name="line.101"></a>
<FONT color="green">102</FONT>         * @return the first component of a key path<a name="line.102"></a>
<FONT color="green">103</FONT>         */<a name="line.103"></a>
<FONT color="green">104</FONT>        public static String rootKeyFromKeyPath(String aString)<a name="line.104"></a>
<FONT color="green">105</FONT>         {<a name="line.105"></a>
<FONT color="green">106</FONT>            /** require [valid_param] aString != null; [valid_keypath] isValidPropertyKeyPath(aString); **/<a name="line.106"></a>
<FONT color="green">107</FONT>    <a name="line.107"></a>
<FONT color="green">108</FONT>            NSMutableArray components = keyPathComponents(aString).mutableClone();<a name="line.108"></a>
<FONT color="green">109</FONT>            return (String)components.objectAtIndex(0);<a name="line.109"></a>
<FONT color="green">110</FONT>    <a name="line.110"></a>
<FONT color="green">111</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.111"></a>
<FONT color="green">112</FONT>         }<a name="line.112"></a>
<FONT color="green">113</FONT>    <a name="line.113"></a>
<FONT color="green">114</FONT>    <a name="line.114"></a>
<FONT color="green">115</FONT>    <a name="line.115"></a>
<FONT color="green">116</FONT>        /**<a name="line.116"></a>
<FONT color="green">117</FONT>         * Given a key path like object1.object2.attribute returns the "object2.attribute" part.<a name="line.117"></a>
<FONT color="green">118</FONT>         *<a name="line.118"></a>
<FONT color="green">119</FONT>         * @param aString the keypath<a name="line.119"></a>
<FONT color="green">120</FONT>         * @return everything in the keypath except the first component<a name="line.120"></a>
<FONT color="green">121</FONT>         */<a name="line.121"></a>
<FONT color="green">122</FONT>        public static String removeRootKeyFromKeyPath(String aString)<a name="line.122"></a>
<FONT color="green">123</FONT>        {<a name="line.123"></a>
<FONT color="green">124</FONT>            /** require [valid_param] aString != null; [valid_keypath] isValidPropertyKeyPath(aString); **/<a name="line.124"></a>
<FONT color="green">125</FONT>    <a name="line.125"></a>
<FONT color="green">126</FONT>            NSMutableArray components = keyPathComponents(aString).mutableClone();<a name="line.126"></a>
<FONT color="green">127</FONT>            components.removeObjectAtIndex(0);<a name="line.127"></a>
<FONT color="green">128</FONT>            return components.componentsJoinedByString(".");<a name="line.128"></a>
<FONT color="green">129</FONT>    <a name="line.129"></a>
<FONT color="green">130</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.130"></a>
<FONT color="green">131</FONT>        }<a name="line.131"></a>
<FONT color="green">132</FONT>    <a name="line.132"></a>
<FONT color="green">133</FONT>    <a name="line.133"></a>
<FONT color="green">134</FONT>    <a name="line.134"></a>
<FONT color="green">135</FONT>        /**<a name="line.135"></a>
<FONT color="green">136</FONT>          * Returns &lt;code&gt;true&lt;/code&gt; if this string is null or the empty String (trim().length() == 0).<a name="line.136"></a>
<FONT color="green">137</FONT>          *<a name="line.137"></a>
<FONT color="green">138</FONT>          * @param aString the string to check<a name="line.138"></a>
<FONT color="green">139</FONT>          * @return &lt;code&gt;true&lt;/code&gt; if this string is null or the empty String (length() == 0)<a name="line.139"></a>
<FONT color="green">140</FONT>          */<a name="line.140"></a>
<FONT color="green">141</FONT>         public static boolean isEmpty(String aString)<a name="line.141"></a>
<FONT color="green">142</FONT>         {<a name="line.142"></a>
<FONT color="green">143</FONT>             return (aString == null) || (aString.trim().length() == 0);<a name="line.143"></a>
<FONT color="green">144</FONT>         }<a name="line.144"></a>
<FONT color="green">145</FONT>    <a name="line.145"></a>
<FONT color="green">146</FONT>    <a name="line.146"></a>
<FONT color="green">147</FONT>    <a name="line.147"></a>
<FONT color="green">148</FONT>        /**<a name="line.148"></a>
<FONT color="green">149</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if this string matched the integer pattern: [whitespace][minussign]digits[whitespace] and &lt;code&gt;false&lt;/code&gt; otherwise.  Note that, unlike a float, an integer cannot be preceded by a plus sign "+".  For more info on Integer literals, see section 3.10.1 of the Java Language Specification.<a name="line.149"></a>
<FONT color="green">150</FONT>         *<a name="line.150"></a>
<FONT color="green">151</FONT>         * @param aString the string to check<a name="line.151"></a>
<FONT color="green">152</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if this string matched the integer pattern, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.152"></a>
<FONT color="green">153</FONT>         */<a name="line.153"></a>
<FONT color="green">154</FONT>        public static boolean isInteger(String aString)<a name="line.154"></a>
<FONT color="green">155</FONT>        {<a name="line.155"></a>
<FONT color="green">156</FONT>            /** require [valid_param] aString != null; **/<a name="line.156"></a>
<FONT color="green">157</FONT>    <a name="line.157"></a>
<FONT color="green">158</FONT>            boolean isInteger = true;<a name="line.158"></a>
<FONT color="green">159</FONT>            try<a name="line.159"></a>
<FONT color="green">160</FONT>            {<a name="line.160"></a>
<FONT color="green">161</FONT>                Integer.valueOf(aString.trim());<a name="line.161"></a>
<FONT color="green">162</FONT>            }<a name="line.162"></a>
<FONT color="green">163</FONT>            catch (NumberFormatException e)<a name="line.163"></a>
<FONT color="green">164</FONT>            {<a name="line.164"></a>
<FONT color="green">165</FONT>                isInteger = false;<a name="line.165"></a>
<FONT color="green">166</FONT>            }<a name="line.166"></a>
<FONT color="green">167</FONT>            return isInteger;<a name="line.167"></a>
<FONT color="green">168</FONT>        }<a name="line.168"></a>
<FONT color="green">169</FONT>    <a name="line.169"></a>
<FONT color="green">170</FONT>    <a name="line.170"></a>
<FONT color="green">171</FONT>        /**<a name="line.171"></a>
<FONT color="green">172</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if this string matched the float pattern: [whitespace][sign]digits[.digits]["e" digits][floating point suffix][whitespace] and &lt;code&gt;false&lt;/code&gt; otherwise.  For more info on Floating point literals, see section 3.10.2 of the Java Language Specification.<a name="line.172"></a>
<FONT color="green">173</FONT>         *<a name="line.173"></a>
<FONT color="green">174</FONT>         * @param aString the string to check<a name="line.174"></a>
<FONT color="green">175</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if this string matched the float pattern, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.175"></a>
<FONT color="green">176</FONT>         */<a name="line.176"></a>
<FONT color="green">177</FONT>        public static boolean isFloat(String aString)<a name="line.177"></a>
<FONT color="green">178</FONT>        {<a name="line.178"></a>
<FONT color="green">179</FONT>            /** require [valid_param] aString != null; **/<a name="line.179"></a>
<FONT color="green">180</FONT>    <a name="line.180"></a>
<FONT color="green">181</FONT>            boolean isFloat = true;<a name="line.181"></a>
<FONT color="green">182</FONT>            try<a name="line.182"></a>
<FONT color="green">183</FONT>            {<a name="line.183"></a>
<FONT color="green">184</FONT>                Float.valueOf(aString.trim());<a name="line.184"></a>
<FONT color="green">185</FONT>            }<a name="line.185"></a>
<FONT color="green">186</FONT>            catch (NumberFormatException e)<a name="line.186"></a>
<FONT color="green">187</FONT>            {<a name="line.187"></a>
<FONT color="green">188</FONT>                isFloat = false;<a name="line.188"></a>
<FONT color="green">189</FONT>            }<a name="line.189"></a>
<FONT color="green">190</FONT>            return isFloat;<a name="line.190"></a>
<FONT color="green">191</FONT>        }<a name="line.191"></a>
<FONT color="green">192</FONT>    <a name="line.192"></a>
<FONT color="green">193</FONT>    <a name="line.193"></a>
<FONT color="green">194</FONT>        /**<a name="line.194"></a>
<FONT color="green">195</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if this string is a number (optionally surrounded by whitespace), &lt;code&gt;false&lt;/code&gt; otherwise.  This method is more restrictive than the above method, since this one will only return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;aString&lt;/code&gt; is actually a number as most humans would understand the term (in particular, no suffixes or base prefixes are allowed).<a name="line.195"></a>
<FONT color="green">196</FONT>         *<a name="line.196"></a>
<FONT color="green">197</FONT>         * @param aString the string to check<a name="line.197"></a>
<FONT color="green">198</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if this string is a number, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.198"></a>
<FONT color="green">199</FONT>         */<a name="line.199"></a>
<FONT color="green">200</FONT>        public static boolean isNumber(String aString)<a name="line.200"></a>
<FONT color="green">201</FONT>        {<a name="line.201"></a>
<FONT color="green">202</FONT>            /** require [valid_param] aString != null; **/<a name="line.202"></a>
<FONT color="green">203</FONT>    <a name="line.203"></a>
<FONT color="green">204</FONT>            boolean isNumber = true;<a name="line.204"></a>
<FONT color="green">205</FONT>            try<a name="line.205"></a>
<FONT color="green">206</FONT>            {<a name="line.206"></a>
<FONT color="green">207</FONT>                new BigDecimal(aString.trim());<a name="line.207"></a>
<FONT color="green">208</FONT>            }<a name="line.208"></a>
<FONT color="green">209</FONT>            catch (NumberFormatException e)<a name="line.209"></a>
<FONT color="green">210</FONT>            {<a name="line.210"></a>
<FONT color="green">211</FONT>                isNumber = false;<a name="line.211"></a>
<FONT color="green">212</FONT>            }<a name="line.212"></a>
<FONT color="green">213</FONT>            // This is needed for a bug in JDK 1.3.1.x<a name="line.213"></a>
<FONT color="green">214</FONT>            catch (StringIndexOutOfBoundsException emptyString)<a name="line.214"></a>
<FONT color="green">215</FONT>            {<a name="line.215"></a>
<FONT color="green">216</FONT>                isNumber = false;<a name="line.216"></a>
<FONT color="green">217</FONT>            }<a name="line.217"></a>
<FONT color="green">218</FONT>    <a name="line.218"></a>
<FONT color="green">219</FONT>            return isNumber;<a name="line.219"></a>
<FONT color="green">220</FONT>        }<a name="line.220"></a>
<FONT color="green">221</FONT>    <a name="line.221"></a>
<FONT color="green">222</FONT>    <a name="line.222"></a>
<FONT color="green">223</FONT>    <a name="line.223"></a>
<FONT color="green">224</FONT>        /**<a name="line.224"></a>
<FONT color="green">225</FONT>         * Return &lt;code&gt;true&lt;/code&gt; if all the characters in the string are digits or white space, &lt;code&gt;false&lt;/code&gt; otherwise.  Unlike &lt;code&gt;isFloat&lt;/code&gt; and &lt;code&gt;isInteger&lt;/code&gt;, this method returns &lt;code&gt;true&lt;/code&gt; on strings like " 12 45 78 " where whitespace exists between the digits.<a name="line.225"></a>
<FONT color="green">226</FONT>         *<a name="line.226"></a>
<FONT color="green">227</FONT>         * @param aString the string to check<a name="line.227"></a>
<FONT color="green">228</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if all the characters in the string are digits or white space, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.228"></a>
<FONT color="green">229</FONT>         */<a name="line.229"></a>
<FONT color="green">230</FONT>        public static boolean isDigits(String aString)<a name="line.230"></a>
<FONT color="green">231</FONT>        {<a name="line.231"></a>
<FONT color="green">232</FONT>            /** require [valid_param] aString != null; **/<a name="line.232"></a>
<FONT color="green">233</FONT>    <a name="line.233"></a>
<FONT color="green">234</FONT>            boolean isDigits = true;<a name="line.234"></a>
<FONT color="green">235</FONT>    <a name="line.235"></a>
<FONT color="green">236</FONT>            int i;<a name="line.236"></a>
<FONT color="green">237</FONT>            int stringLength = aString.length();<a name="line.237"></a>
<FONT color="green">238</FONT>    <a name="line.238"></a>
<FONT color="green">239</FONT>            //traverse the characters of the string and return false once a character is not a digit or whitespace<a name="line.239"></a>
<FONT color="green">240</FONT>            for (i = 0; i &lt; stringLength; i++ )<a name="line.240"></a>
<FONT color="green">241</FONT>            {<a name="line.241"></a>
<FONT color="green">242</FONT>                if ( ! (Character.isDigit(aString.charAt(i)) || Character.isWhitespace(aString.charAt(i))))<a name="line.242"></a>
<FONT color="green">243</FONT>                {<a name="line.243"></a>
<FONT color="green">244</FONT>                    isDigits = false;<a name="line.244"></a>
<FONT color="green">245</FONT>                    break;<a name="line.245"></a>
<FONT color="green">246</FONT>                }<a name="line.246"></a>
<FONT color="green">247</FONT>            }<a name="line.247"></a>
<FONT color="green">248</FONT>    <a name="line.248"></a>
<FONT color="green">249</FONT>            return isDigits;<a name="line.249"></a>
<FONT color="green">250</FONT>        }<a name="line.250"></a>
<FONT color="green">251</FONT>    <a name="line.251"></a>
<FONT color="green">252</FONT>    <a name="line.252"></a>
<FONT color="green">253</FONT>    <a name="line.253"></a>
<FONT color="green">254</FONT>        /**<a name="line.254"></a>
<FONT color="green">255</FONT>         * Return &lt;code&gt;true&lt;/code&gt; if all the characters in the string are alphabetic, &lt;code&gt;false&lt;/code&gt; otherwise.<a name="line.255"></a>
<FONT color="green">256</FONT>         *<a name="line.256"></a>
<FONT color="green">257</FONT>         * @param aString the string to check<a name="line.257"></a>
<FONT color="green">258</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if all the characters in the string are alphabetic, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.258"></a>
<FONT color="green">259</FONT>         */<a name="line.259"></a>
<FONT color="green">260</FONT>        public static boolean isAlphaOnly(String aString)<a name="line.260"></a>
<FONT color="green">261</FONT>        {<a name="line.261"></a>
<FONT color="green">262</FONT>            /** require [valid_param] aString != null; **/<a name="line.262"></a>
<FONT color="green">263</FONT>    <a name="line.263"></a>
<FONT color="green">264</FONT>            boolean isAlphaOnly = true;<a name="line.264"></a>
<FONT color="green">265</FONT>    <a name="line.265"></a>
<FONT color="green">266</FONT>            for (int i = 0; isAlphaOnly &amp;&amp; i &lt; aString.length(); i++ )<a name="line.266"></a>
<FONT color="green">267</FONT>            {<a name="line.267"></a>
<FONT color="green">268</FONT>                if ( ! Character.isLetter(aString.charAt(i)))<a name="line.268"></a>
<FONT color="green">269</FONT>                {<a name="line.269"></a>
<FONT color="green">270</FONT>                    isAlphaOnly = false;<a name="line.270"></a>
<FONT color="green">271</FONT>                }<a name="line.271"></a>
<FONT color="green">272</FONT>            }<a name="line.272"></a>
<FONT color="green">273</FONT>    <a name="line.273"></a>
<FONT color="green">274</FONT>            return isAlphaOnly;<a name="line.274"></a>
<FONT color="green">275</FONT>        }<a name="line.275"></a>
<FONT color="green">276</FONT>    <a name="line.276"></a>
<FONT color="green">277</FONT>    <a name="line.277"></a>
<FONT color="green">278</FONT>    <a name="line.278"></a>
<FONT color="green">279</FONT>        /**<a name="line.279"></a>
<FONT color="green">280</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;character&lt;/code&gt; is a line break character.<a name="line.280"></a>
<FONT color="green">281</FONT>         *<a name="line.281"></a>
<FONT color="green">282</FONT>         * @param character the character to check<a name="line.282"></a>
<FONT color="green">283</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;character&lt;/code&gt; is a line break character<a name="line.283"></a>
<FONT color="green">284</FONT>         */<a name="line.284"></a>
<FONT color="green">285</FONT>        public static boolean isLineBreak(char character)<a name="line.285"></a>
<FONT color="green">286</FONT>        {<a name="line.286"></a>
<FONT color="green">287</FONT>            return (character == '\n') || (character == '\r');<a name="line.287"></a>
<FONT color="green">288</FONT>        }<a name="line.288"></a>
<FONT color="green">289</FONT>    <a name="line.289"></a>
<FONT color="green">290</FONT>    <a name="line.290"></a>
<FONT color="green">291</FONT>    <a name="line.291"></a>
<FONT color="green">292</FONT>        /**<a name="line.292"></a>
<FONT color="green">293</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;firstCharacter&lt;/code&gt; and<a name="line.293"></a>
<FONT color="green">294</FONT>         * &lt;code&gt;secondCharacter&lt;/code&gt; are not equal and are both a line break<a name="line.294"></a>
<FONT color="green">295</FONT>         * character.  This is useful when parsing files which have /n/r or /r/n<a name="line.295"></a>
<FONT color="green">296</FONT>         * for a single line break.<a name="line.296"></a>
<FONT color="green">297</FONT>         *<a name="line.297"></a>
<FONT color="green">298</FONT>         * @see #isLineBreak(char)<a name="line.298"></a>
<FONT color="green">299</FONT>         * @param firstCharacter the first character in the line break sequence<a name="line.299"></a>
<FONT color="green">300</FONT>         * @param secondCharacter the last character in the line break sequence<a name="line.300"></a>
<FONT color="green">301</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;firstCharacter&lt;/code&gt; and<a name="line.301"></a>
<FONT color="green">302</FONT>         * &lt;code&gt;secondCharacter&lt;/code&gt; form a single line break<a name="line.302"></a>
<FONT color="green">303</FONT>         */<a name="line.303"></a>
<FONT color="green">304</FONT>        public static boolean isLineBreakContinuation(char firstCharacter,<a name="line.304"></a>
<FONT color="green">305</FONT>                                                      char secondCharacter)<a name="line.305"></a>
<FONT color="green">306</FONT>        {<a name="line.306"></a>
<FONT color="green">307</FONT>            return (firstCharacter != secondCharacter) &amp;&amp;<a name="line.307"></a>
<FONT color="green">308</FONT>            ((firstCharacter == '\n') || (firstCharacter == '\r')) &amp;&amp;<a name="line.308"></a>
<FONT color="green">309</FONT>            ((secondCharacter == '\n') || (secondCharacter == '\r'));<a name="line.309"></a>
<FONT color="green">310</FONT>        }<a name="line.310"></a>
<FONT color="green">311</FONT>    <a name="line.311"></a>
<FONT color="green">312</FONT>    <a name="line.312"></a>
<FONT color="green">313</FONT>    <a name="line.313"></a>
<FONT color="green">314</FONT>        /**<a name="line.314"></a>
<FONT color="green">315</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;anEmail&lt;/code&gt; is of valid email format: "&amp;lt;string&amp;gt;@&amp;lt;string&amp;gt;.&amp;lt;string&amp;gt;" where &amp;lt;string&amp;gt; is not empty, &lt;code&gt;false&lt;/code&gt; otherwise.<a name="line.315"></a>
<FONT color="green">316</FONT>         *<a name="line.316"></a>
<FONT color="green">317</FONT>         * @deprecated Use the method in EmailAddress in GVCMail instead.<a name="line.317"></a>
<FONT color="green">318</FONT>         * @param anEmail the string to check<a name="line.318"></a>
<FONT color="green">319</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;anEmail&lt;/code&gt; is of valid email format, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.319"></a>
<FONT color="green">320</FONT>         */<a name="line.320"></a>
<FONT color="green">321</FONT>        public static boolean isValidEmailAddressFormat(String anEmail)<a name="line.321"></a>
<FONT color="green">322</FONT>        {<a name="line.322"></a>
<FONT color="green">323</FONT>            /** require [valid_param] anEmail != null; **/<a name="line.323"></a>
<FONT color="green">324</FONT>    <a name="line.324"></a>
<FONT color="green">325</FONT>            NSArray listItems = NSArray.componentsSeparatedByString(anEmail, "@");<a name="line.325"></a>
<FONT color="green">326</FONT>            boolean hasAtSignInMiddle = (listItems.count() == 2) &amp;&amp;<a name="line.326"></a>
<FONT color="green">327</FONT>                (((String)listItems.objectAtIndex(0)).length() &gt; 0) &amp;&amp;<a name="line.327"></a>
<FONT color="green">328</FONT>                (((String)listItems.objectAtIndex(1)).length() &gt; 0);<a name="line.328"></a>
<FONT color="green">329</FONT>    <a name="line.329"></a>
<FONT color="green">330</FONT>            boolean hasValidDomain = false;<a name="line.330"></a>
<FONT color="green">331</FONT>            if (hasAtSignInMiddle)<a name="line.331"></a>
<FONT color="green">332</FONT>            {<a name="line.332"></a>
<FONT color="green">333</FONT>                NSArray domainItems = NSArray.componentsSeparatedByString((String)listItems.objectAtIndex(1), ".");<a name="line.333"></a>
<FONT color="green">334</FONT>                hasValidDomain = (domainItems.count() &gt;= 2) &amp;&amp;<a name="line.334"></a>
<FONT color="green">335</FONT>                    (((String)domainItems.objectAtIndex(0)).length() &gt; 0) &amp;&amp;<a name="line.335"></a>
<FONT color="green">336</FONT>                    (((String)domainItems.objectAtIndex(1)).length() &gt; 0);<a name="line.336"></a>
<FONT color="green">337</FONT>            }<a name="line.337"></a>
<FONT color="green">338</FONT>    <a name="line.338"></a>
<FONT color="green">339</FONT>            return hasAtSignInMiddle &amp;&amp; hasValidDomain;<a name="line.339"></a>
<FONT color="green">340</FONT>        }<a name="line.340"></a>
<FONT color="green">341</FONT>    <a name="line.341"></a>
<FONT color="green">342</FONT>    <a name="line.342"></a>
<FONT color="green">343</FONT>    <a name="line.343"></a>
<FONT color="green">344</FONT>        /**<a name="line.344"></a>
<FONT color="green">345</FONT>         * This will determine if an array of words is contained within the string. Either ensuring all words are matched, or at least 1 word is matched.  Case does not matter.<a name="line.345"></a>
<FONT color="green">346</FONT>         * Worker method to support &lt;code&gt;doesStringContainAllWordsInArray&lt;/code&gt;, &lt;code&gt;doesStringContainAnyWordsInArray&lt;/code&gt;, &lt;code&gt;doesStringContainAllWordsInString&lt;/code&gt;, &lt;code&gt;doesStringContainAnyWordsInString&lt;/code&gt;.<a name="line.346"></a>
<FONT color="green">347</FONT>         *<a name="line.347"></a>
<FONT color="green">348</FONT>         * @param stringToSearch the string to search<a name="line.348"></a>
<FONT color="green">349</FONT>         * @param collectionOfWords collection of strings to search for<a name="line.349"></a>
<FONT color="green">350</FONT>         * @param ensureAllWordsMatched &lt;code&gt;true&lt;/code&gt; if all words in &lt;code&gt;arrayOfWords&lt;/code&gt; should be matched<a name="line.350"></a>
<FONT color="green">351</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if at least one word in &lt;code&gt;arrayOfWords&lt;/code&gt; exists in &lt;code&gt;stringToSearch&lt;/code&gt; and &lt;code&gt;ensureAllWordsMatched&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; if all words in &lt;code&gt;arrayOfWords&lt;/code&gt; exists in &lt;code&gt;stringToSearch&lt;/code&gt; and &lt;code&gt;ensureAllWordsMatched&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.351"></a>
<FONT color="green">352</FONT>         */<a name="line.352"></a>
<FONT color="green">353</FONT>        public static boolean doesStringContainWordsInCollection(String stringToSearch,<a name="line.353"></a>
<FONT color="green">354</FONT>                                                                 Object collectionOfWords,<a name="line.354"></a>
<FONT color="green">355</FONT>                                                                 boolean ensureAllWordsMatched)<a name="line.355"></a>
<FONT color="green">356</FONT>        {<a name="line.356"></a>
<FONT color="green">357</FONT>            /** require<a name="line.357"></a>
<FONT color="green">358</FONT>            [valid_stringToSearch_param] stringToSearch != null;<a name="line.358"></a>
<FONT color="green">359</FONT>            [valid_collectionOfWords_param] collectionOfWords != null;<a name="line.359"></a>
<FONT color="green">360</FONT>            [is_collection_of_strings] Collection.collectionContainsInstancesOf(collectionOfWords, ClassAdditions.unsafeClassForName("java.lang.String")); **/<a name="line.360"></a>
<FONT color="green">361</FONT>    <a name="line.361"></a>
<FONT color="green">362</FONT>            boolean isContained;<a name="line.362"></a>
<FONT color="green">363</FONT>    <a name="line.363"></a>
<FONT color="green">364</FONT>            String upperStringToSearch = stringToSearch.toUpperCase();<a name="line.364"></a>
<FONT color="green">365</FONT>            Enumeration wordEnumerator = Collection.enumerationForCollection(collectionOfWords);<a name="line.365"></a>
<FONT color="green">366</FONT>    <a name="line.366"></a>
<FONT color="green">367</FONT>            isContained = false;<a name="line.367"></a>
<FONT color="green">368</FONT>            while (wordEnumerator.hasMoreElements())<a name="line.368"></a>
<FONT color="green">369</FONT>            {<a name="line.369"></a>
<FONT color="green">370</FONT>                String thisWord = (String)wordEnumerator.nextElement();<a name="line.370"></a>
<FONT color="green">371</FONT>    <a name="line.371"></a>
<FONT color="green">372</FONT>                if (thisWord.length() &gt; 0)<a name="line.372"></a>
<FONT color="green">373</FONT>                {<a name="line.373"></a>
<FONT color="green">374</FONT>                    int index = upperStringToSearch.indexOf(thisWord.toUpperCase());<a name="line.374"></a>
<FONT color="green">375</FONT>                    if (index != -1)<a name="line.375"></a>
<FONT color="green">376</FONT>                    {<a name="line.376"></a>
<FONT color="green">377</FONT>                        isContained = true;<a name="line.377"></a>
<FONT color="green">378</FONT>                        if ( ! ensureAllWordsMatched)<a name="line.378"></a>
<FONT color="green">379</FONT>                        {<a name="line.379"></a>
<FONT color="green">380</FONT>                            break;<a name="line.380"></a>
<FONT color="green">381</FONT>                        }<a name="line.381"></a>
<FONT color="green">382</FONT>                    }<a name="line.382"></a>
<FONT color="green">383</FONT>                    else<a name="line.383"></a>
<FONT color="green">384</FONT>                    {<a name="line.384"></a>
<FONT color="green">385</FONT>                        if (ensureAllWordsMatched)<a name="line.385"></a>
<FONT color="green">386</FONT>                        {<a name="line.386"></a>
<FONT color="green">387</FONT>                            isContained = false;<a name="line.387"></a>
<FONT color="green">388</FONT>                            break;<a name="line.388"></a>
<FONT color="green">389</FONT>                        }<a name="line.389"></a>
<FONT color="green">390</FONT>                    }<a name="line.390"></a>
<FONT color="green">391</FONT>                }<a name="line.391"></a>
<FONT color="green">392</FONT>            }<a name="line.392"></a>
<FONT color="green">393</FONT>    <a name="line.393"></a>
<FONT color="green">394</FONT>            return isContained;<a name="line.394"></a>
<FONT color="green">395</FONT>        }<a name="line.395"></a>
<FONT color="green">396</FONT>    <a name="line.396"></a>
<FONT color="green">397</FONT>    <a name="line.397"></a>
<FONT color="green">398</FONT>    <a name="line.398"></a>
<FONT color="green">399</FONT>        /**<a name="line.399"></a>
<FONT color="green">400</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains any words in &lt;code&gt;stringOfWords&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.<a name="line.400"></a>
<FONT color="green">401</FONT>         *<a name="line.401"></a>
<FONT color="green">402</FONT>         * @param stringToSearch the string to search<a name="line.402"></a>
<FONT color="green">403</FONT>         * @param stringOfWords the words that we want to look for, separated by spaces<a name="line.403"></a>
<FONT color="green">404</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains any words in &lt;code&gt;collectionOfWords&lt;/code&gt;<a name="line.404"></a>
<FONT color="green">405</FONT>         */<a name="line.405"></a>
<FONT color="green">406</FONT>        public static boolean doesStringContainAnyWordsInString(String stringToSearch, String stringOfWords)<a name="line.406"></a>
<FONT color="green">407</FONT>        {<a name="line.407"></a>
<FONT color="green">408</FONT>            /** require<a name="line.408"></a>
<FONT color="green">409</FONT>            [valid_stringToSearch_param] stringToSearch != null;<a name="line.409"></a>
<FONT color="green">410</FONT>            [valid_stringOfWords_param] stringOfWords != null; **/<a name="line.410"></a>
<FONT color="green">411</FONT>    <a name="line.411"></a>
<FONT color="green">412</FONT>            NSArray arrayOfWords = NSArray.componentsSeparatedByString(stringOfWords, " ");<a name="line.412"></a>
<FONT color="green">413</FONT>            return doesStringContainWordsInCollection(stringToSearch, arrayOfWords, false);<a name="line.413"></a>
<FONT color="green">414</FONT>        }<a name="line.414"></a>
<FONT color="green">415</FONT>    <a name="line.415"></a>
<FONT color="green">416</FONT>    <a name="line.416"></a>
<FONT color="green">417</FONT>    <a name="line.417"></a>
<FONT color="green">418</FONT>        /**<a name="line.418"></a>
<FONT color="green">419</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains all the words in &lt;code&gt;stringOfWords&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.<a name="line.419"></a>
<FONT color="green">420</FONT>         *<a name="line.420"></a>
<FONT color="green">421</FONT>         * @param stringToSearch the string to search<a name="line.421"></a>
<FONT color="green">422</FONT>         * @param stringOfWords the words that we want to look for, separated by spaces<a name="line.422"></a>
<FONT color="green">423</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains all the words in &lt;code&gt;collectionOfWords&lt;/code&gt;<a name="line.423"></a>
<FONT color="green">424</FONT>         */<a name="line.424"></a>
<FONT color="green">425</FONT>        public static boolean doesStringContainAllWordsInString(String stringToSearch, String stringOfWords)<a name="line.425"></a>
<FONT color="green">426</FONT>        {<a name="line.426"></a>
<FONT color="green">427</FONT>            /** require<a name="line.427"></a>
<FONT color="green">428</FONT>            [valid_stringToSearch_param] stringToSearch != null;<a name="line.428"></a>
<FONT color="green">429</FONT>            [valid_stringOfWords_param] stringOfWords != null; **/<a name="line.429"></a>
<FONT color="green">430</FONT>    <a name="line.430"></a>
<FONT color="green">431</FONT>            NSArray arrayOfWords = NSArray.componentsSeparatedByString(stringOfWords, " ");<a name="line.431"></a>
<FONT color="green">432</FONT>            return doesStringContainWordsInCollection(stringToSearch, arrayOfWords, true);<a name="line.432"></a>
<FONT color="green">433</FONT>        }<a name="line.433"></a>
<FONT color="green">434</FONT>    <a name="line.434"></a>
<FONT color="green">435</FONT>    <a name="line.435"></a>
<FONT color="green">436</FONT>    <a name="line.436"></a>
<FONT color="green">437</FONT>        /**<a name="line.437"></a>
<FONT color="green">438</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains any words in &lt;code&gt;arrayOfWords&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.<a name="line.438"></a>
<FONT color="green">439</FONT>         *<a name="line.439"></a>
<FONT color="green">440</FONT>         * @param stringToSearch the string to search<a name="line.440"></a>
<FONT color="green">441</FONT>         * @param collectionOfWords the words that we want to look for<a name="line.441"></a>
<FONT color="green">442</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains any words in the collection &lt;code&gt;arrayOfWords&lt;/code&gt;<a name="line.442"></a>
<FONT color="green">443</FONT>         */<a name="line.443"></a>
<FONT color="green">444</FONT>        public static boolean doesStringContainAnyWordsInCollection(String stringToSearch, Object collectionOfWords)<a name="line.444"></a>
<FONT color="green">445</FONT>        {<a name="line.445"></a>
<FONT color="green">446</FONT>            /** require<a name="line.446"></a>
<FONT color="green">447</FONT>            [valid_stringToSearch_param] stringToSearch != null;<a name="line.447"></a>
<FONT color="green">448</FONT>            [valid_collectionOfWords_param] collectionOfWords != null;<a name="line.448"></a>
<FONT color="green">449</FONT>            [is_collection_of_strings] Collection.collectionContainsInstancesOf(collectionOfWords, ClassAdditions.unsafeClassForName("java.lang.String")); **/<a name="line.449"></a>
<FONT color="green">450</FONT>    <a name="line.450"></a>
<FONT color="green">451</FONT>            return doesStringContainWordsInCollection(stringToSearch, collectionOfWords, false);<a name="line.451"></a>
<FONT color="green">452</FONT>        }<a name="line.452"></a>
<FONT color="green">453</FONT>    <a name="line.453"></a>
<FONT color="green">454</FONT>    <a name="line.454"></a>
<FONT color="green">455</FONT>    <a name="line.455"></a>
<FONT color="green">456</FONT>        /**<a name="line.456"></a>
<FONT color="green">457</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains all the words in &lt;code&gt;arrayOfWords&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.<a name="line.457"></a>
<FONT color="green">458</FONT>         *<a name="line.458"></a>
<FONT color="green">459</FONT>         * @param stringToSearch the string to search<a name="line.459"></a>
<FONT color="green">460</FONT>         * @param collectionOfWords the words that we want to look for<a name="line.460"></a>
<FONT color="green">461</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;stringToSearch&lt;/code&gt; contains all the words in the collection &lt;code&gt;arrayOfWords&lt;/code&gt;<a name="line.461"></a>
<FONT color="green">462</FONT>         */<a name="line.462"></a>
<FONT color="green">463</FONT>        public static boolean doesStringContainAllWordsInCollection(String stringToSearch, Object collectionOfWords)<a name="line.463"></a>
<FONT color="green">464</FONT>        {<a name="line.464"></a>
<FONT color="green">465</FONT>            /** require<a name="line.465"></a>
<FONT color="green">466</FONT>            [valid_stringToSearch_param] stringToSearch != null;<a name="line.466"></a>
<FONT color="green">467</FONT>            [valid_collectionOfWords_param] collectionOfWords != null;<a name="line.467"></a>
<FONT color="green">468</FONT>            [is_collection_of_strings] Collection.collectionContainsInstancesOf(collectionOfWords, ClassAdditions.unsafeClassForName("java.lang.String")); **/<a name="line.468"></a>
<FONT color="green">469</FONT>    <a name="line.469"></a>
<FONT color="green">470</FONT>            return doesStringContainWordsInCollection(stringToSearch, collectionOfWords, true);<a name="line.470"></a>
<FONT color="green">471</FONT>        }<a name="line.471"></a>
<FONT color="green">472</FONT>    <a name="line.472"></a>
<FONT color="green">473</FONT>    <a name="line.473"></a>
<FONT color="green">474</FONT>    <a name="line.474"></a>
<FONT color="green">475</FONT>        /**<a name="line.475"></a>
<FONT color="green">476</FONT>         * Escapes &lt;code&gt;characterToEscape&lt;/code&gt; in the given string with &lt;code&gt;escapeCharacter&lt;/code&gt;.<a name="line.476"></a>
<FONT color="green">477</FONT>         *<a name="line.477"></a>
<FONT color="green">478</FONT>         * @param sourceString the string to escape<a name="line.478"></a>
<FONT color="green">479</FONT>         * @param stringToEscape the character that will be escaped<a name="line.479"></a>
<FONT color="green">480</FONT>         * @param escapeString the string to escape the &lt;code&gt;stringToEscape&lt;/code&gt; with<a name="line.480"></a>
<FONT color="green">481</FONT>         * @return the string properly escaped<a name="line.481"></a>
<FONT color="green">482</FONT>         */<a name="line.482"></a>
<FONT color="green">483</FONT>        public static String escape(String sourceString, String stringToEscape, String escapeString)<a name="line.483"></a>
<FONT color="green">484</FONT>        {<a name="line.484"></a>
<FONT color="green">485</FONT>            /** require<a name="line.485"></a>
<FONT color="green">486</FONT>            [valid_sourceString_param] sourceString != null;<a name="line.486"></a>
<FONT color="green">487</FONT>            [valid_stringToEscape_param] stringToEscape != null;<a name="line.487"></a>
<FONT color="green">488</FONT>            [valid_escapeString_param] escapeString != null; **/<a name="line.488"></a>
<FONT color="green">489</FONT>    <a name="line.489"></a>
<FONT color="green">490</FONT>            StringBuffer resultingString = new StringBuffer();<a name="line.490"></a>
<FONT color="green">491</FONT>    <a name="line.491"></a>
<FONT color="green">492</FONT>            for (int i = 0; i &lt; sourceString.length(); i++)<a name="line.492"></a>
<FONT color="green">493</FONT>            {<a name="line.493"></a>
<FONT color="green">494</FONT>                if ((i + stringToEscape.length() &lt;= sourceString.length()) &amp;&amp; (sourceString.substring(i, i + stringToEscape.length()).equals(stringToEscape)))<a name="line.494"></a>
<FONT color="green">495</FONT>                {<a name="line.495"></a>
<FONT color="green">496</FONT>                    resultingString.append(escapeString);<a name="line.496"></a>
<FONT color="green">497</FONT>                }<a name="line.497"></a>
<FONT color="green">498</FONT>                resultingString.append(sourceString.charAt(i));<a name="line.498"></a>
<FONT color="green">499</FONT>            }<a name="line.499"></a>
<FONT color="green">500</FONT>    <a name="line.500"></a>
<FONT color="green">501</FONT>            return resultingString.toString();<a name="line.501"></a>
<FONT color="green">502</FONT>    <a name="line.502"></a>
<FONT color="green">503</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.503"></a>
<FONT color="green">504</FONT>        }<a name="line.504"></a>
<FONT color="green">505</FONT>    <a name="line.505"></a>
<FONT color="green">506</FONT>    <a name="line.506"></a>
<FONT color="green">507</FONT>    <a name="line.507"></a>
<FONT color="green">508</FONT>        /**<a name="line.508"></a>
<FONT color="green">509</FONT>         * Escapes &lt;code&gt;characterToEscape&lt;/code&gt; in the given string with &lt;code&gt;escapeCharacter&lt;/code&gt;.<a name="line.509"></a>
<FONT color="green">510</FONT>         *<a name="line.510"></a>
<FONT color="green">511</FONT>         * @param sourceString the string to escape<a name="line.511"></a>
<FONT color="green">512</FONT>         * @param characterToEscape the character that will be escaped<a name="line.512"></a>
<FONT color="green">513</FONT>         * @param escapeCharacter the character to escape the &lt;code&gt;characterToEscape&lt;/code&gt; with<a name="line.513"></a>
<FONT color="green">514</FONT>         * @return the string properly escaped<a name="line.514"></a>
<FONT color="green">515</FONT>         */<a name="line.515"></a>
<FONT color="green">516</FONT>        public static String escape(String sourceString, char characterToEscape, char escapeCharacter)<a name="line.516"></a>
<FONT color="green">517</FONT>        {<a name="line.517"></a>
<FONT color="green">518</FONT>            /** require [valid_sourceString_param] sourceString != null; **/<a name="line.518"></a>
<FONT color="green">519</FONT>            return escape(sourceString, new String(new char[] {characterToEscape}), new String(new char[] {escapeCharacter}));<a name="line.519"></a>
<FONT color="green">520</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.520"></a>
<FONT color="green">521</FONT>        }<a name="line.521"></a>
<FONT color="green">522</FONT>    <a name="line.522"></a>
<FONT color="green">523</FONT>    <a name="line.523"></a>
<FONT color="green">524</FONT>    <a name="line.524"></a>
<FONT color="green">525</FONT>        /**<a name="line.525"></a>
<FONT color="green">526</FONT>         * Converts &lt;code&gt;sourceString&lt;/code&gt; to a valid SQL for FrontBase. Currently, EOF has a known bug in Java: it does not properly quote string literals. When this method is called, it will add "'" to both sides of the string and add the FrontBase's escape character (which is "'") for all occurences of "'".<a name="line.526"></a>
<FONT color="green">527</FONT>         * eg. "Smith" =&gt; "'Smith'"<a name="line.527"></a>
<FONT color="green">528</FONT>         *     "O'Brien" =&gt; "'O''Brien'"<a name="line.528"></a>
<FONT color="green">529</FONT>         *<a name="line.529"></a>
<FONT color="green">530</FONT>         * @param sourceString the string to convert<a name="line.530"></a>
<FONT color="green">531</FONT>         * @return the string properly quoted<a name="line.531"></a>
<FONT color="green">532</FONT>         */<a name="line.532"></a>
<FONT color="green">533</FONT>        public static String escapeSQLForFrontBase(String sourceString)<a name="line.533"></a>
<FONT color="green">534</FONT>        {<a name="line.534"></a>
<FONT color="green">535</FONT>            /** require [valid_param] sourceString != null; **/<a name="line.535"></a>
<FONT color="green">536</FONT>    <a name="line.536"></a>
<FONT color="green">537</FONT>            String resultingString = escape(sourceString, '\'', '\'');<a name="line.537"></a>
<FONT color="green">538</FONT>            resultingString = "'" + resultingString + "'";<a name="line.538"></a>
<FONT color="green">539</FONT>    <a name="line.539"></a>
<FONT color="green">540</FONT>            JassAdditions.post("StringAdditions", "escapeSQLForFrontBase", resultingString.charAt(0) == '\'' &amp;&amp; resultingString.charAt(resultingString.length() - 1) == '\'');<a name="line.540"></a>
<FONT color="green">541</FONT>            return resultingString;<a name="line.541"></a>
<FONT color="green">542</FONT>    <a name="line.542"></a>
<FONT color="green">543</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.543"></a>
<FONT color="green">544</FONT>        }<a name="line.544"></a>
<FONT color="green">545</FONT>    <a name="line.545"></a>
<FONT color="green">546</FONT>    <a name="line.546"></a>
<FONT color="green">547</FONT>    <a name="line.547"></a>
<FONT color="green">548</FONT>        /**<a name="line.548"></a>
<FONT color="green">549</FONT>         * Pads a string to the specified number of chars with the given pad char.<a name="line.549"></a>
<FONT color="green">550</FONT>         *<a name="line.550"></a>
<FONT color="green">551</FONT>         * @param string the string to pad<a name="line.551"></a>
<FONT color="green">552</FONT>         * @param padChar the character to pad with<a name="line.552"></a>
<FONT color="green">553</FONT>         * @param paddedLength the length to pad to<a name="line.553"></a>
<FONT color="green">554</FONT>         * @return the padded string<a name="line.554"></a>
<FONT color="green">555</FONT>         */<a name="line.555"></a>
<FONT color="green">556</FONT>        public static String pad(String string, char padChar, int paddedLength)<a name="line.556"></a>
<FONT color="green">557</FONT>        {<a name="line.557"></a>
<FONT color="green">558</FONT>            /** require [valid_string_param] string != null; **/<a name="line.558"></a>
<FONT color="green">559</FONT>            JassAdditions.pre("StringAdditions", "pad", string.length() &lt;= paddedLength);<a name="line.559"></a>
<FONT color="green">560</FONT>    <a name="line.560"></a>
<FONT color="green">561</FONT>            StringBuffer buffer = new StringBuffer(string);<a name="line.561"></a>
<FONT color="green">562</FONT>            for (int i = string.length(); i &lt; paddedLength; i++)<a name="line.562"></a>
<FONT color="green">563</FONT>            {<a name="line.563"></a>
<FONT color="green">564</FONT>                buffer.append(padChar);<a name="line.564"></a>
<FONT color="green">565</FONT>            }<a name="line.565"></a>
<FONT color="green">566</FONT>            String resultString = buffer.toString();<a name="line.566"></a>
<FONT color="green">567</FONT>    <a name="line.567"></a>
<FONT color="green">568</FONT>            JassAdditions.post("StringAdditions", "pad", resultString.length() == paddedLength);<a name="line.568"></a>
<FONT color="green">569</FONT>            return resultString;<a name="line.569"></a>
<FONT color="green">570</FONT>    <a name="line.570"></a>
<FONT color="green">571</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.571"></a>
<FONT color="green">572</FONT>        }<a name="line.572"></a>
<FONT color="green">573</FONT>    <a name="line.573"></a>
<FONT color="green">574</FONT>    <a name="line.574"></a>
<FONT color="green">575</FONT>    <a name="line.575"></a>
<FONT color="green">576</FONT>        /**<a name="line.576"></a>
<FONT color="green">577</FONT>         * Downcases the first letter of the given string.<a name="line.577"></a>
<FONT color="green">578</FONT>         *<a name="line.578"></a>
<FONT color="green">579</FONT>         * @param string the string to downcase<a name="line.579"></a>
<FONT color="green">580</FONT>         * @return the string with the first letter downcased<a name="line.580"></a>
<FONT color="green">581</FONT>         */<a name="line.581"></a>
<FONT color="green">582</FONT>        public static String downcaseFirstLetter(String string)<a name="line.582"></a>
<FONT color="green">583</FONT>        {<a name="line.583"></a>
<FONT color="green">584</FONT>            /** require [valid_param] string != null; **/<a name="line.584"></a>
<FONT color="green">585</FONT>    <a name="line.585"></a>
<FONT color="green">586</FONT>            String result = string.substring(0, 1).toLowerCase() + string.substring(1);<a name="line.586"></a>
<FONT color="green">587</FONT>    <a name="line.587"></a>
<FONT color="green">588</FONT>            JassAdditions.post("StringAdditions", "downcaseFirstLetter", result.substring(0, 1).equals(string.substring(0, 1).toLowerCase()) &amp;&amp; result.substring(1).equals(string.substring(1)));<a name="line.588"></a>
<FONT color="green">589</FONT>            return result;<a name="line.589"></a>
<FONT color="green">590</FONT>    <a name="line.590"></a>
<FONT color="green">591</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.591"></a>
<FONT color="green">592</FONT>        }<a name="line.592"></a>
<FONT color="green">593</FONT>    <a name="line.593"></a>
<FONT color="green">594</FONT>    <a name="line.594"></a>
<FONT color="green">595</FONT>    <a name="line.595"></a>
<FONT color="green">596</FONT>        /**<a name="line.596"></a>
<FONT color="green">597</FONT>         * Returns the last element of &lt;code&gt;wholePath&lt;/code&gt;.  This does not use<a name="line.597"></a>
<FONT color="green">598</FONT>         * the pathSeparator system property.  This is for files uploaded through a<a name="line.598"></a>
<FONT color="green">599</FONT>         * browser, so it accomodates forward slash AND backslash pathSeparators.<a name="line.599"></a>
<FONT color="green">600</FONT>         *<a name="line.600"></a>
<FONT color="green">601</FONT>         * @param wholePath path to return the last path component (filename) from<a name="line.601"></a>
<FONT color="green">602</FONT>         * @return the last path component (filename) of &lt;code&gt;wholePath&lt;/code&gt;<a name="line.602"></a>
<FONT color="green">603</FONT>         */<a name="line.603"></a>
<FONT color="green">604</FONT>        public static String lastPathComponentXPlatform(String wholePath)<a name="line.604"></a>
<FONT color="green">605</FONT>        {<a name="line.605"></a>
<FONT color="green">606</FONT>            /** require [valid_path] wholePath != null;  **/<a name="line.606"></a>
<FONT color="green">607</FONT>    <a name="line.607"></a>
<FONT color="green">608</FONT>            while (wholePath.endsWith("\\") || wholePath.endsWith("/"))<a name="line.608"></a>
<FONT color="green">609</FONT>            {<a name="line.609"></a>
<FONT color="green">610</FONT>                wholePath = wholePath.substring(0, wholePath.length() - 1);<a name="line.610"></a>
<FONT color="green">611</FONT>            }<a name="line.611"></a>
<FONT color="green">612</FONT>    <a name="line.612"></a>
<FONT color="green">613</FONT>            int lastSlash = wholePath.lastIndexOf("\\");<a name="line.613"></a>
<FONT color="green">614</FONT>            String lastPathComponent = wholePath;<a name="line.614"></a>
<FONT color="green">615</FONT>    <a name="line.615"></a>
<FONT color="green">616</FONT>            // If we did not find the backslash, try  the forwardSlash<a name="line.616"></a>
<FONT color="green">617</FONT>            if ( lastSlash &lt; 0)<a name="line.617"></a>
<FONT color="green">618</FONT>            {<a name="line.618"></a>
<FONT color="green">619</FONT>                lastSlash = wholePath.lastIndexOf("/");<a name="line.619"></a>
<FONT color="green">620</FONT>            }<a name="line.620"></a>
<FONT color="green">621</FONT>    <a name="line.621"></a>
<FONT color="green">622</FONT>            if ( lastSlash &gt; -1)<a name="line.622"></a>
<FONT color="green">623</FONT>            {<a name="line.623"></a>
<FONT color="green">624</FONT>                lastPathComponent = wholePath.substring(lastSlash + 1);<a name="line.624"></a>
<FONT color="green">625</FONT>            }<a name="line.625"></a>
<FONT color="green">626</FONT>    <a name="line.626"></a>
<FONT color="green">627</FONT>    <a name="line.627"></a>
<FONT color="green">628</FONT>            return lastPathComponent;<a name="line.628"></a>
<FONT color="green">629</FONT>            /** ensure [valid_result] Result != null;<a name="line.629"></a>
<FONT color="green">630</FONT>                       [path_ends_in_name] wholePath.endsWith(Result);     **/<a name="line.630"></a>
<FONT color="green">631</FONT>        }<a name="line.631"></a>
<FONT color="green">632</FONT>    <a name="line.632"></a>
<FONT color="green">633</FONT>    <a name="line.633"></a>
<FONT color="green">634</FONT>    <a name="line.634"></a>
<FONT color="green">635</FONT>    <a name="line.635"></a>
<FONT color="green">636</FONT>        /**<a name="line.636"></a>
<FONT color="green">637</FONT>         * Return a random string of length length.  Useful to create passwords.<a name="line.637"></a>
<FONT color="green">638</FONT>         *<a name="line.638"></a>
<FONT color="green">639</FONT>         * @param length the length of random string to create<a name="line.639"></a>
<FONT color="green">640</FONT>         * @param charset characters that can appear in the random string<a name="line.640"></a>
<FONT color="green">641</FONT>         * @return a random string of length length<a name="line.641"></a>
<FONT color="green">642</FONT>         */<a name="line.642"></a>
<FONT color="green">643</FONT>        public static String randomStringWithLengthFromCharset(int length, String charset)<a name="line.643"></a>
<FONT color="green">644</FONT>        {<a name="line.644"></a>
<FONT color="green">645</FONT>            /** require<a name="line.645"></a>
<FONT color="green">646</FONT>            [valid_length] length &gt;= 0;<a name="line.646"></a>
<FONT color="green">647</FONT>            [valid_charset] charset != null; **/<a name="line.647"></a>
<FONT color="green">648</FONT>    <a name="line.648"></a>
<FONT color="green">649</FONT>            char[] randomString = new char[length];<a name="line.649"></a>
<FONT color="green">650</FONT>    <a name="line.650"></a>
<FONT color="green">651</FONT>            for(int i = 0; i &lt; length; i++) {<a name="line.651"></a>
<FONT color="green">652</FONT>                int num = generator.nextInt(charset.length());<a name="line.652"></a>
<FONT color="green">653</FONT>                randomString[i] = charset.charAt(num);<a name="line.653"></a>
<FONT color="green">654</FONT>            }<a name="line.654"></a>
<FONT color="green">655</FONT>    <a name="line.655"></a>
<FONT color="green">656</FONT>            return new String(randomString);<a name="line.656"></a>
<FONT color="green">657</FONT>    <a name="line.657"></a>
<FONT color="green">658</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.658"></a>
<FONT color="green">659</FONT>        }<a name="line.659"></a>
<FONT color="green">660</FONT>    <a name="line.660"></a>
<FONT color="green">661</FONT>    <a name="line.661"></a>
<FONT color="green">662</FONT>    }<a name="line.662"></a>




























































</PRE>
</BODY>
</HTML>
