<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    package net.global_village.virtualtables;<a name="line.1"></a>
<FONT color="green">002</FONT>    <a name="line.2"></a>
<FONT color="green">003</FONT>    import java.io.*;<a name="line.3"></a>
<FONT color="green">004</FONT>    import java.sql.*;<a name="line.4"></a>
<FONT color="green">005</FONT>    import java.text.*;<a name="line.5"></a>
<FONT color="green">006</FONT>    import java.text.ParseException;<a name="line.6"></a>
<FONT color="green">007</FONT>    import java.util.*;<a name="line.7"></a>
<FONT color="green">008</FONT>    <a name="line.8"></a>
<FONT color="green">009</FONT>    import net.global_village.eofextensions.*;<a name="line.9"></a>
<FONT color="green">010</FONT>    import net.global_village.foundation.*;<a name="line.10"></a>
<FONT color="green">011</FONT>    import net.global_village.foundation.Date;<a name="line.11"></a>
<FONT color="green">012</FONT>    import ognl.*;<a name="line.12"></a>
<FONT color="green">013</FONT>    import ognl.webobjects.*;<a name="line.13"></a>
<FONT color="green">014</FONT>    <a name="line.14"></a>
<FONT color="green">015</FONT>    import com.webobjects.eoaccess.*;<a name="line.15"></a>
<FONT color="green">016</FONT>    import com.webobjects.eocontrol.*;<a name="line.16"></a>
<FONT color="green">017</FONT>    import com.webobjects.foundation.*;<a name="line.17"></a>
<FONT color="green">018</FONT>    import com.webobjects.jdbcadaptor.*;<a name="line.18"></a>
<FONT color="green">019</FONT>    <a name="line.19"></a>
<FONT color="green">020</FONT>    import er.extensions.foundation.*;<a name="line.20"></a>
<FONT color="green">021</FONT>    <a name="line.21"></a>
<FONT color="green">022</FONT>    <a name="line.22"></a>
<FONT color="green">023</FONT>    /**<a name="line.23"></a>
<FONT color="green">024</FONT>     * A table that is not represented on disk by an actual database table, but by a "virtual" table.<a name="line.24"></a>
<FONT color="green">025</FONT>     *<a name="line.25"></a>
<FONT color="green">026</FONT>     * @author Copyright (c) 2001-2010  Global Village Consulting, Inc.  All rights reserved.<a name="line.26"></a>
<FONT color="green">027</FONT>     * This software is published under the terms of the Educational Community License (ECL) version 1.0,<a name="line.27"></a>
<FONT color="green">028</FONT>     * a copy of which has been included with this distribution in the LICENSE.TXT file.<a name="line.28"></a>
<FONT color="green">029</FONT>     * @version $Revision: 21$<a name="line.29"></a>
<FONT color="green">030</FONT>     */<a name="line.30"></a>
<FONT color="green">031</FONT>    public class VirtualTable extends _VirtualTable<a name="line.31"></a>
<FONT color="green">032</FONT>    {<a name="line.32"></a>
<FONT color="green">033</FONT>        protected static IntegerPrimaryKeyGenerator pkGenerator = null;<a name="line.33"></a>
<FONT color="green">034</FONT>        protected static NSArray accessorMutatorPrefixes = new NSArray(new String [] {"get", "set", "is", "_", "_get", "_is", "_set"});<a name="line.34"></a>
<FONT color="green">035</FONT>            public static final String STRING_ENCODING = "UTF-8";<a name="line.35"></a>
<FONT color="green">036</FONT>    <a name="line.36"></a>
<FONT color="green">037</FONT>    <a name="line.37"></a>
<FONT color="green">038</FONT>        /**<a name="line.38"></a>
<FONT color="green">039</FONT>         * Returns &lt;code&gt;true&lt;/code&gt; if there is a PK generator ready for use, &lt;code&gt;false&lt;/code&gt; otherwise.<a name="line.39"></a>
<FONT color="green">040</FONT>         *<a name="line.40"></a>
<FONT color="green">041</FONT>         * @return &lt;code&gt;true&lt;/code&gt; if there is a PK generator ready for use, &lt;code&gt;false&lt;/code&gt; otherwise<a name="line.41"></a>
<FONT color="green">042</FONT>         */<a name="line.42"></a>
<FONT color="green">043</FONT>        public static synchronized boolean hasPKGenerator()<a name="line.43"></a>
<FONT color="green">044</FONT>        {<a name="line.44"></a>
<FONT color="green">045</FONT>            return pkGenerator != null;<a name="line.45"></a>
<FONT color="green">046</FONT>        }<a name="line.46"></a>
<FONT color="green">047</FONT>    <a name="line.47"></a>
<FONT color="green">048</FONT>    <a name="line.48"></a>
<FONT color="green">049</FONT>    <a name="line.49"></a>
<FONT color="green">050</FONT>        /**<a name="line.50"></a>
<FONT color="green">051</FONT>         * Initializes the PK generator.  NOTE: any other delegate on the DB context will be overwriten with extreme prejudice.<a name="line.51"></a>
<FONT color="green">052</FONT>         *<a name="line.52"></a>
<FONT color="green">053</FONT>         * @param additionalEntitiesToCache additional entities that this PK generator will generate PKs for.  Primarily designed for Table, Column and Field subclasses, but could be used for anything<a name="line.53"></a>
<FONT color="green">054</FONT>         * @param numberOfPKsToCache the number of PK to cache<a name="line.54"></a>
<FONT color="green">055</FONT>         */<a name="line.55"></a>
<FONT color="green">056</FONT>        public static synchronized void startCachingPKs(int numberOfPKsToCache, NSArray additionalEntitiesToCache)<a name="line.56"></a>
<FONT color="green">057</FONT>        {<a name="line.57"></a>
<FONT color="green">058</FONT>            /** require<a name="line.58"></a>
<FONT color="green">059</FONT>            [no_pk_generator] ! hasPKGenerator();<a name="line.59"></a>
<FONT color="green">060</FONT>            [valid_additionalEntitiesToCache_param] additionalEntitiesToCache != null; **/<a name="line.60"></a>
<FONT color="green">061</FONT>    <a name="line.61"></a>
<FONT color="green">062</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.62"></a>
<FONT color="green">063</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.63"></a>
<FONT color="green">064</FONT>    <a name="line.64"></a>
<FONT color="green">065</FONT>            pkGenerator = new FBIntegerPrimaryKeyGenerator(numberOfPKsToCache);<a name="line.65"></a>
<FONT color="green">066</FONT>            pkGenerator.cachePKsForModel(vtModel);<a name="line.66"></a>
<FONT color="green">067</FONT>    <a name="line.67"></a>
<FONT color="green">068</FONT>            Enumeration additionalEntitiesToCacheEnumerator = additionalEntitiesToCache.objectEnumerator();<a name="line.68"></a>
<FONT color="green">069</FONT>            while (additionalEntitiesToCacheEnumerator.hasMoreElements())<a name="line.69"></a>
<FONT color="green">070</FONT>            {<a name="line.70"></a>
<FONT color="green">071</FONT>                EOEntity entity = (EOEntity)additionalEntitiesToCacheEnumerator.nextElement();<a name="line.71"></a>
<FONT color="green">072</FONT>                pkGenerator.cachePKsForEntity(entity);<a name="line.72"></a>
<FONT color="green">073</FONT>            }<a name="line.73"></a>
<FONT color="green">074</FONT>    <a name="line.74"></a>
<FONT color="green">075</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, EOObjectStoreCoordinator.defaultCoordinator());<a name="line.75"></a>
<FONT color="green">076</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.76"></a>
<FONT color="green">077</FONT>    <a name="line.77"></a>
<FONT color="green">078</FONT>            dbContext.lock();<a name="line.78"></a>
<FONT color="green">079</FONT>            try<a name="line.79"></a>
<FONT color="green">080</FONT>            {<a name="line.80"></a>
<FONT color="green">081</FONT>                dbContext.setDelegate(pkGenerator);<a name="line.81"></a>
<FONT color="green">082</FONT>            }<a name="line.82"></a>
<FONT color="green">083</FONT>            finally<a name="line.83"></a>
<FONT color="green">084</FONT>            {<a name="line.84"></a>
<FONT color="green">085</FONT>                dbContext.unlock();<a name="line.85"></a>
<FONT color="green">086</FONT>            }<a name="line.86"></a>
<FONT color="green">087</FONT>            /** ensure [has_pk_generator] hasPKGenerator(); **/<a name="line.87"></a>
<FONT color="green">088</FONT>        }<a name="line.88"></a>
<FONT color="green">089</FONT>    <a name="line.89"></a>
<FONT color="green">090</FONT>    <a name="line.90"></a>
<FONT color="green">091</FONT>        /**<a name="line.91"></a>
<FONT color="green">092</FONT>         * Removes the PK generator.  The DB Context's delegate is set to &lt;code&gt;null&lt;/code&gt;.<a name="line.92"></a>
<FONT color="green">093</FONT>         */<a name="line.93"></a>
<FONT color="green">094</FONT>        public static synchronized void stopCachingPKs()<a name="line.94"></a>
<FONT color="green">095</FONT>        {<a name="line.95"></a>
<FONT color="green">096</FONT>            /** require [has_pk_generator] hasPKGenerator(); **/<a name="line.96"></a>
<FONT color="green">097</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.97"></a>
<FONT color="green">098</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.98"></a>
<FONT color="green">099</FONT>    <a name="line.99"></a>
<FONT color="green">100</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, EOObjectStoreCoordinator.defaultCoordinator());<a name="line.100"></a>
<FONT color="green">101</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.101"></a>
<FONT color="green">102</FONT>    <a name="line.102"></a>
<FONT color="green">103</FONT>            dbContext.lock();<a name="line.103"></a>
<FONT color="green">104</FONT>            try<a name="line.104"></a>
<FONT color="green">105</FONT>            {<a name="line.105"></a>
<FONT color="green">106</FONT>                dbContext.setDelegate(null);<a name="line.106"></a>
<FONT color="green">107</FONT>                pkGenerator = null;<a name="line.107"></a>
<FONT color="green">108</FONT>            }<a name="line.108"></a>
<FONT color="green">109</FONT>            finally<a name="line.109"></a>
<FONT color="green">110</FONT>            {<a name="line.110"></a>
<FONT color="green">111</FONT>                dbContext.unlock();<a name="line.111"></a>
<FONT color="green">112</FONT>            }<a name="line.112"></a>
<FONT color="green">113</FONT>    <a name="line.113"></a>
<FONT color="green">114</FONT>            /** ensure [pk_generator_cleared] ! hasPKGenerator(); **/<a name="line.114"></a>
<FONT color="green">115</FONT>        }<a name="line.115"></a>
<FONT color="green">116</FONT>    <a name="line.116"></a>
<FONT color="green">117</FONT>    <a name="line.117"></a>
<FONT color="green">118</FONT>        /**<a name="line.118"></a>
<FONT color="green">119</FONT>         * Initializes the VT engine.  Right now, that means setting up the DB context<a name="line.119"></a>
<FONT color="green">120</FONT>         * delegate to provide quicker primary keys. NOTE: any other delegate on the DB context<a name="line.120"></a>
<FONT color="green">121</FONT>         * will be overwritten with extreme prejudice.<a name="line.121"></a>
<FONT color="green">122</FONT>         *<a name="line.122"></a>
<FONT color="green">123</FONT>         * @param numberOfPKsToCache the number of PK to cache<a name="line.123"></a>
<FONT color="green">124</FONT>         * @param additionalEntitiesToCache additional entities that this PK generator<a name="line.124"></a>
<FONT color="green">125</FONT>         * will generate PKs for.  Primarily designed for Table, Column and Field<a name="line.125"></a>
<FONT color="green">126</FONT>         * subclasses, but could be used for anything<a name="line.126"></a>
<FONT color="green">127</FONT>         */<a name="line.127"></a>
<FONT color="green">128</FONT>        public static synchronized void initializeVirtualTables(int numberOfPKsToCache, NSArray additionalEntitiesToCache)<a name="line.128"></a>
<FONT color="green">129</FONT>        {<a name="line.129"></a>
<FONT color="green">130</FONT>            /** require [valid_additionalEntitiesToCache_param] additionalEntitiesToCache != null; **/<a name="line.130"></a>
<FONT color="green">131</FONT>    <a name="line.131"></a>
<FONT color="green">132</FONT>            if (numberOfPKsToCache &gt; 0)<a name="line.132"></a>
<FONT color="green">133</FONT>            {<a name="line.133"></a>
<FONT color="green">134</FONT>                System.out.println("************* startCachingPKs");<a name="line.134"></a>
<FONT color="green">135</FONT>                startCachingPKs(numberOfPKsToCache, additionalEntitiesToCache);<a name="line.135"></a>
<FONT color="green">136</FONT>            }<a name="line.136"></a>
<FONT color="green">137</FONT>    <a name="line.137"></a>
<FONT color="green">138</FONT>            WOOgnl.factory().configureWOForOgnl();<a name="line.138"></a>
<FONT color="green">139</FONT>    <a name="line.139"></a>
<FONT color="green">140</FONT>            // Allow virtual column access by name<a name="line.140"></a>
<FONT color="green">141</FONT>            OgnlRuntime.setPropertyAccessor(VirtualRow.class, new VirtualRowPropertyAccessor());<a name="line.141"></a>
<FONT color="green">142</FONT>            OgnlRuntime.setPropertyAccessor(VirtualTable.class, new VirtualTablePropertyAccessor());<a name="line.142"></a>
<FONT color="green">143</FONT>    <a name="line.143"></a>
<FONT color="green">144</FONT>            // Add useful methods<a name="line.144"></a>
<FONT color="green">145</FONT>            OgnlRuntime.setMethodAccessor(NSTimestamp.class, new NSTimestampMethodAccessor());<a name="line.145"></a>
<FONT color="green">146</FONT>            OgnlRuntime.setMethodAccessor(java.lang.String.class, new StringMethodAccessor());<a name="line.146"></a>
<FONT color="green">147</FONT>            OgnlRuntime.setMethodAccessor(java.math.BigDecimal.class, new BigDecimalMethodAccessor());<a name="line.147"></a>
<FONT color="green">148</FONT>        }<a name="line.148"></a>
<FONT color="green">149</FONT>    <a name="line.149"></a>
<FONT color="green">150</FONT>    <a name="line.150"></a>
<FONT color="green">151</FONT>    <a name="line.151"></a>
<FONT color="green">152</FONT>        /**<a name="line.152"></a>
<FONT color="green">153</FONT>         * Creates and returns a new table in the given editing context.<a name="line.153"></a>
<FONT color="green">154</FONT>         *<a name="line.154"></a>
<FONT color="green">155</FONT>         * @param ec the editing context into which to create a new virtual table<a name="line.155"></a>
<FONT color="green">156</FONT>         * @param name the name of the new table<a name="line.156"></a>
<FONT color="green">157</FONT>         * @return a new table in the given editing context with the given name<a name="line.157"></a>
<FONT color="green">158</FONT>         */<a name="line.158"></a>
<FONT color="green">159</FONT>        public static VirtualTable createVirtualTable(EOEditingContext ec, String name)<a name="line.159"></a>
<FONT color="green">160</FONT>        {<a name="line.160"></a>
<FONT color="green">161</FONT>            /** require<a name="line.161"></a>
<FONT color="green">162</FONT>            [valid_ec_param] ec != null;<a name="line.162"></a>
<FONT color="green">163</FONT>            [valid_name_param] name != null; **/<a name="line.163"></a>
<FONT color="green">164</FONT>    <a name="line.164"></a>
<FONT color="green">165</FONT>            VirtualTable newTable = new VirtualTable();<a name="line.165"></a>
<FONT color="green">166</FONT>            ec.insertObject(newTable);<a name="line.166"></a>
<FONT color="green">167</FONT>            newTable.setName(name);<a name="line.167"></a>
<FONT color="green">168</FONT>            return newTable;<a name="line.168"></a>
<FONT color="green">169</FONT>    <a name="line.169"></a>
<FONT color="green">170</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.170"></a>
<FONT color="green">171</FONT>        }<a name="line.171"></a>
<FONT color="green">172</FONT>    <a name="line.172"></a>
<FONT color="green">173</FONT>    <a name="line.173"></a>
<FONT color="green">174</FONT>    <a name="line.174"></a>
<FONT color="green">175</FONT>        /**<a name="line.175"></a>
<FONT color="green">176</FONT>         * Setup default values.<a name="line.176"></a>
<FONT color="green">177</FONT>         *<a name="line.177"></a>
<FONT color="green">178</FONT>         * @param ec the editing context in which this is being inserted<a name="line.178"></a>
<FONT color="green">179</FONT>         */<a name="line.179"></a>
<FONT color="green">180</FONT>        public void awakeFromInsertion(EOEditingContext ec)<a name="line.180"></a>
<FONT color="green">181</FONT>        {<a name="line.181"></a>
<FONT color="green">182</FONT>            /** require [valid_param] ec != null; **/<a name="line.182"></a>
<FONT color="green">183</FONT>    <a name="line.183"></a>
<FONT color="green">184</FONT>            super.awakeFromInsertion(ec);<a name="line.184"></a>
<FONT color="green">185</FONT>    <a name="line.185"></a>
<FONT color="green">186</FONT>            Column column = newColumn(dateCreatedColumnName(), ColumnType.TimestampColumnType);<a name="line.186"></a>
<FONT color="green">187</FONT>            column.setIsSystemColumn(net.global_village.foundation.GVCBoolean.yes());<a name="line.187"></a>
<FONT color="green">188</FONT>    <a name="line.188"></a>
<FONT color="green">189</FONT>            column = newColumn(dateModifiedColumnName(), ColumnType.TimestampColumnType);<a name="line.189"></a>
<FONT color="green">190</FONT>            column.setIsSystemColumn(net.global_village.foundation.GVCBoolean.yes());<a name="line.190"></a>
<FONT color="green">191</FONT>        }<a name="line.191"></a>
<FONT color="green">192</FONT>    <a name="line.192"></a>
<FONT color="green">193</FONT>    <a name="line.193"></a>
<FONT color="green">194</FONT>    <a name="line.194"></a>
<FONT color="green">195</FONT>        /**<a name="line.195"></a>
<FONT color="green">196</FONT>         * Looks in &lt;code&gt;names&lt;/code&gt; for names that begin with one of the standard KVC prefixes ("get", "set", "is", "_", "_get", "_is").  Any such names are munged to remove the prefix.  Also, if the munged name begins with a capital letter, then the first letter is lowercased and also added to the set.<a name="line.196"></a>
<FONT color="green">197</FONT>         *<a name="line.197"></a>
<FONT color="green">198</FONT>         * @return the munged column names<a name="line.198"></a>
<FONT color="green">199</FONT>         */<a name="line.199"></a>
<FONT color="green">200</FONT>        protected NSSet mungeInvalidAccessorMutatorPrefixes(NSArray names)<a name="line.200"></a>
<FONT color="green">201</FONT>        {<a name="line.201"></a>
<FONT color="green">202</FONT>            /** require [valid_param] names != null; **/<a name="line.202"></a>
<FONT color="green">203</FONT>    <a name="line.203"></a>
<FONT color="green">204</FONT>            NSMutableSet mungedNames = new NSMutableSet();<a name="line.204"></a>
<FONT color="green">205</FONT>            Enumeration nameEnumerator = names.objectEnumerator();<a name="line.205"></a>
<FONT color="green">206</FONT>            while (nameEnumerator.hasMoreElements())<a name="line.206"></a>
<FONT color="green">207</FONT>            {<a name="line.207"></a>
<FONT color="green">208</FONT>                String name = (String)nameEnumerator.nextElement();<a name="line.208"></a>
<FONT color="green">209</FONT>    <a name="line.209"></a>
<FONT color="green">210</FONT>                Enumeration prefixEnumerator = accessorMutatorPrefixes.objectEnumerator();<a name="line.210"></a>
<FONT color="green">211</FONT>                while (prefixEnumerator.hasMoreElements())<a name="line.211"></a>
<FONT color="green">212</FONT>                {<a name="line.212"></a>
<FONT color="green">213</FONT>                    String prefix = (String)prefixEnumerator.nextElement();<a name="line.213"></a>
<FONT color="green">214</FONT>                    if (name.startsWith(prefix))<a name="line.214"></a>
<FONT color="green">215</FONT>                    {<a name="line.215"></a>
<FONT color="green">216</FONT>                        String mungedName = name.substring(prefix.length());<a name="line.216"></a>
<FONT color="green">217</FONT>                        mungedNames.addObject(mungedName);<a name="line.217"></a>
<FONT color="green">218</FONT>                        if (Character.isUpperCase(mungedName.charAt(0)))<a name="line.218"></a>
<FONT color="green">219</FONT>                        {<a name="line.219"></a>
<FONT color="green">220</FONT>                            mungedNames.addObject(StringAdditions.downcaseFirstLetter(mungedName));<a name="line.220"></a>
<FONT color="green">221</FONT>                        }<a name="line.221"></a>
<FONT color="green">222</FONT>                    }<a name="line.222"></a>
<FONT color="green">223</FONT>                }<a name="line.223"></a>
<FONT color="green">224</FONT>            }<a name="line.224"></a>
<FONT color="green">225</FONT>            return mungedNames;<a name="line.225"></a>
<FONT color="green">226</FONT>    <a name="line.226"></a>
<FONT color="green">227</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.227"></a>
<FONT color="green">228</FONT>        }<a name="line.228"></a>
<FONT color="green">229</FONT>    <a name="line.229"></a>
<FONT color="green">230</FONT>    <a name="line.230"></a>
<FONT color="green">231</FONT>    <a name="line.231"></a>
<FONT color="green">232</FONT>        /**<a name="line.232"></a>
<FONT color="green">233</FONT>         * Returns the default set of invalid column names.<a name="line.233"></a>
<FONT color="green">234</FONT>         *<a name="line.234"></a>
<FONT color="green">235</FONT>         * @return the column names that are invalid due to conflict with method or field names on VirtualRow<a name="line.235"></a>
<FONT color="green">236</FONT>         */<a name="line.236"></a>
<FONT color="green">237</FONT>        protected NSMutableSet defaultInvalidColumnNames()<a name="line.237"></a>
<FONT color="green">238</FONT>        {<a name="line.238"></a>
<FONT color="green">239</FONT>            NSMutableSet defaultInvalidColumnNames = super.defaultInvalidColumnNames();<a name="line.239"></a>
<FONT color="green">240</FONT>    <a name="line.240"></a>
<FONT color="green">241</FONT>            NSArray methods = new NSArray(VirtualRow.class.getMethods());<a name="line.241"></a>
<FONT color="green">242</FONT>            NSArray methodNames = (NSArray)methods.valueForKey("name");<a name="line.242"></a>
<FONT color="green">243</FONT>            NSArray fields = new NSArray(VirtualRow.class.getFields());<a name="line.243"></a>
<FONT color="green">244</FONT>            NSArray fieldNames = (NSArray)fields.valueForKey("name");<a name="line.244"></a>
<FONT color="green">245</FONT>    <a name="line.245"></a>
<FONT color="green">246</FONT>            defaultInvalidColumnNames.addObjectsFromArray(methodNames);<a name="line.246"></a>
<FONT color="green">247</FONT>            defaultInvalidColumnNames.addObjectsFromArray(fieldNames);<a name="line.247"></a>
<FONT color="green">248</FONT>            defaultInvalidColumnNames.unionSet(mungeInvalidAccessorMutatorPrefixes(methodNames));<a name="line.248"></a>
<FONT color="green">249</FONT>            defaultInvalidColumnNames.unionSet(mungeInvalidAccessorMutatorPrefixes(fieldNames));<a name="line.249"></a>
<FONT color="green">250</FONT>    <a name="line.250"></a>
<FONT color="green">251</FONT>            return defaultInvalidColumnNames;<a name="line.251"></a>
<FONT color="green">252</FONT>    <a name="line.252"></a>
<FONT color="green">253</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.253"></a>
<FONT color="green">254</FONT>        }<a name="line.254"></a>
<FONT color="green">255</FONT>    <a name="line.255"></a>
<FONT color="green">256</FONT>    <a name="line.256"></a>
<FONT color="green">257</FONT>    <a name="line.257"></a>
<FONT color="green">258</FONT>        /**<a name="line.258"></a>
<FONT color="green">259</FONT>         * Makes sure that all the rows and fields are in memory so that we can do in-memory evaluation without firing off a million faults.  We make use of the pre-fetching facilities of fetch specs to accomplish this.  Note that this is likely not really needed due to the batch faulting facility of the EOModel.<a name="line.259"></a>
<FONT color="green">260</FONT>         */<a name="line.260"></a>
<FONT color="green">261</FONT>        protected void cacheData()<a name="line.261"></a>
<FONT color="green">262</FONT>        {<a name="line.262"></a>
<FONT color="green">263</FONT>            NSDictionary bindings = new NSDictionary(tableID(), "tableID");<a name="line.263"></a>
<FONT color="green">264</FONT>            EOUtilities.objectWithFetchSpecificationAndBindings(editingContext(), "VirtualTable", "cacheTableWithTableID", bindings);<a name="line.264"></a>
<FONT color="green">265</FONT>        }<a name="line.265"></a>
<FONT color="green">266</FONT>    <a name="line.266"></a>
<FONT color="green">267</FONT>    <a name="line.267"></a>
<FONT color="green">268</FONT>    <a name="line.268"></a>
<FONT color="green">269</FONT>        /**<a name="line.269"></a>
<FONT color="green">270</FONT>         * Fetches and returns the objects specified by the qualifier.  Note that a &lt;code&gt;VirtualTable&lt;/code&gt; cannot handle SQL qualifiers.  Also note that you should use the normalized name of a column, not its name, as in:&lt;br&gt;<a name="line.270"></a>
<FONT color="green">271</FONT>         * &lt;code&gt;String normalizedName = Column.normalizedStringForColumnNames(name);<a name="line.271"></a>
<FONT color="green">272</FONT>         * EOQualifier qualifier = new EOQualifier.qualifierWithFormat(normalizedName + " = 'hello'");&lt;/code&gt;&lt;br&gt;<a name="line.272"></a>
<FONT color="green">273</FONT>         * If &lt;code&gt;qualifier&lt;/code&gt; is null all objects are returned.<a name="line.273"></a>
<FONT color="green">274</FONT>         *<a name="line.274"></a>
<FONT color="green">275</FONT>         * @param qualifier the qualifier that specifies which objects to return, null to return all objects<a name="line.275"></a>
<FONT color="green">276</FONT>         * @return the fetched objects<a name="line.276"></a>
<FONT color="green">277</FONT>         */<a name="line.277"></a>
<FONT color="green">278</FONT>        public NSArray objectsWithQualifier(EOQualifier qualifier)<a name="line.278"></a>
<FONT color="green">279</FONT>        {<a name="line.279"></a>
<FONT color="green">280</FONT>            //cacheData();  See note in cacheData() above...<a name="line.280"></a>
<FONT color="green">281</FONT>            return (qualifier != null) ? EOQualifier.filteredArrayWithQualifier(rows(), qualifier) : rows();<a name="line.281"></a>
<FONT color="green">282</FONT>    <a name="line.282"></a>
<FONT color="green">283</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.283"></a>
<FONT color="green">284</FONT>        }<a name="line.284"></a>
<FONT color="green">285</FONT>    <a name="line.285"></a>
<FONT color="green">286</FONT>    <a name="line.286"></a>
<FONT color="green">287</FONT>    <a name="line.287"></a>
<FONT color="green">288</FONT>        /**<a name="line.288"></a>
<FONT color="green">289</FONT>         * Returns the object (row) specified by the primary key.<a name="line.289"></a>
<FONT color="green">290</FONT>         *<a name="line.290"></a>
<FONT color="green">291</FONT>         * @param primaryKey - an object that specifies a primary key appropriate for this table<a name="line.291"></a>
<FONT color="green">292</FONT>         * @return object with matching primary key<a name="line.292"></a>
<FONT color="green">293</FONT>         * @exception EOObjectNotAvailableException - if there is no matching object<a name="line.293"></a>
<FONT color="green">294</FONT>         */<a name="line.294"></a>
<FONT color="green">295</FONT>        public EOEnterpriseObject objectWithPrimaryKey(Object primaryKey) throws com.webobjects.eoaccess.EOObjectNotAvailableException<a name="line.295"></a>
<FONT color="green">296</FONT>        {<a name="line.296"></a>
<FONT color="green">297</FONT>            EOEnterpriseObject object = EOUtilities.faultWithPrimaryKeyValue(editingContext(), "VirtualRow", primaryKey);<a name="line.297"></a>
<FONT color="green">298</FONT>    <a name="line.298"></a>
<FONT color="green">299</FONT>            if (EOObject.isDummyFaultEO(object))<a name="line.299"></a>
<FONT color="green">300</FONT>            {<a name="line.300"></a>
<FONT color="green">301</FONT>                throw new com.webobjects.eoaccess.EOObjectNotAvailableException("Can't find VirtualRow with PK " + primaryKey);<a name="line.301"></a>
<FONT color="green">302</FONT>            }<a name="line.302"></a>
<FONT color="green">303</FONT>    <a name="line.303"></a>
<FONT color="green">304</FONT>            return object;<a name="line.304"></a>
<FONT color="green">305</FONT>    <a name="line.305"></a>
<FONT color="green">306</FONT>            /** ensure [valid_result] Result != null;  **/<a name="line.306"></a>
<FONT color="green">307</FONT>        }<a name="line.307"></a>
<FONT color="green">308</FONT>    <a name="line.308"></a>
<FONT color="green">309</FONT>    <a name="line.309"></a>
<FONT color="green">310</FONT>    <a name="line.310"></a>
<FONT color="green">311</FONT>        /**<a name="line.311"></a>
<FONT color="green">312</FONT>         * Creates a new virtual column of the given type and inserts it into the table's editing context.<a name="line.312"></a>
<FONT color="green">313</FONT>         *<a name="line.313"></a>
<FONT color="green">314</FONT>         * @param type the column type to create<a name="line.314"></a>
<FONT color="green">315</FONT>         * @return the newly created column<a name="line.315"></a>
<FONT color="green">316</FONT>         */<a name="line.316"></a>
<FONT color="green">317</FONT>        protected Column createAndInsertColumn(ColumnType type)<a name="line.317"></a>
<FONT color="green">318</FONT>        {<a name="line.318"></a>
<FONT color="green">319</FONT>            /** require<a name="line.319"></a>
<FONT color="green">320</FONT>            [valid_param] type != null;<a name="line.320"></a>
<FONT color="green">321</FONT>            [same_ec] editingContext().equals(type.editingContext()); **/<a name="line.321"></a>
<FONT color="green">322</FONT>    <a name="line.322"></a>
<FONT color="green">323</FONT>            String virtualColumnEntityName = "Virtual" + type.entityNameRestrictor() + "Column";<a name="line.323"></a>
<FONT color="green">324</FONT>            return (Column)EOUtilities.createAndInsertInstance(editingContext(), virtualColumnEntityName);<a name="line.324"></a>
<FONT color="green">325</FONT>    <a name="line.325"></a>
<FONT color="green">326</FONT>            /** ensure<a name="line.326"></a>
<FONT color="green">327</FONT>            [valid_result] Result != null;<a name="line.327"></a>
<FONT color="green">328</FONT>            [in_table_ec] editingContext().equals(Result.editingContext()); **/<a name="line.328"></a>
<FONT color="green">329</FONT>        }<a name="line.329"></a>
<FONT color="green">330</FONT>    <a name="line.330"></a>
<FONT color="green">331</FONT>    <a name="line.331"></a>
<FONT color="green">332</FONT>    <a name="line.332"></a>
<FONT color="green">333</FONT>        /**<a name="line.333"></a>
<FONT color="green">334</FONT>         * Creates a new row that is appropriate for this table.<a name="line.334"></a>
<FONT color="green">335</FONT>         *<a name="line.335"></a>
<FONT color="green">336</FONT>         * @return the newly created row<a name="line.336"></a>
<FONT color="green">337</FONT>         */<a name="line.337"></a>
<FONT color="green">338</FONT>        protected VirtualRow createAndInsertRow()<a name="line.338"></a>
<FONT color="green">339</FONT>        {<a name="line.339"></a>
<FONT color="green">340</FONT>            VirtualRow row = new VirtualRow();<a name="line.340"></a>
<FONT color="green">341</FONT>            editingContext().insertObject(row);<a name="line.341"></a>
<FONT color="green">342</FONT>            return row;<a name="line.342"></a>
<FONT color="green">343</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.343"></a>
<FONT color="green">344</FONT>        }<a name="line.344"></a>
<FONT color="green">345</FONT>    <a name="line.345"></a>
<FONT color="green">346</FONT>    <a name="line.346"></a>
<FONT color="green">347</FONT>    <a name="line.347"></a>
<FONT color="green">348</FONT>        /**<a name="line.348"></a>
<FONT color="green">349</FONT>         * Creates a new row, inserts it into this object's editing context and links up the table relationship.<a name="line.349"></a>
<FONT color="green">350</FONT>         *<a name="line.350"></a>
<FONT color="green">351</FONT>         * @return the newly created and inserted row<a name="line.351"></a>
<FONT color="green">352</FONT>         */<a name="line.352"></a>
<FONT color="green">353</FONT>        public VirtualRow newRow()<a name="line.353"></a>
<FONT color="green">354</FONT>        {<a name="line.354"></a>
<FONT color="green">355</FONT>            VirtualRow row = createAndInsertRow();<a name="line.355"></a>
<FONT color="green">356</FONT>    <a name="line.356"></a>
<FONT color="green">357</FONT>            addObjectToBothSidesOfRelationshipWithKey(row, "rows");<a name="line.357"></a>
<FONT color="green">358</FONT>    <a name="line.358"></a>
<FONT color="green">359</FONT>            row.takeValueForKey(Date.now(), dateCreatedColumnName());<a name="line.359"></a>
<FONT color="green">360</FONT>            row.takeValueForKey(Date.now(), dateModifiedColumnName());<a name="line.360"></a>
<FONT color="green">361</FONT>    <a name="line.361"></a>
<FONT color="green">362</FONT>            return row;<a name="line.362"></a>
<FONT color="green">363</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.363"></a>
<FONT color="green">364</FONT>        }<a name="line.364"></a>
<FONT color="green">365</FONT>    <a name="line.365"></a>
<FONT color="green">366</FONT>    <a name="line.366"></a>
<FONT color="green">367</FONT>    <a name="line.367"></a>
<FONT color="green">368</FONT>        /**<a name="line.368"></a>
<FONT color="green">369</FONT>             * Returns the name to use for the standard "date created" system column.  Subclasses can override this to use a different name.<a name="line.369"></a>
<FONT color="green">370</FONT>         *<a name="line.370"></a>
<FONT color="green">371</FONT>         * @return  the name to use for the standard "date created" system column.<a name="line.371"></a>
<FONT color="green">372</FONT>         */<a name="line.372"></a>
<FONT color="green">373</FONT>        public String dateCreatedColumnName()<a name="line.373"></a>
<FONT color="green">374</FONT>        {<a name="line.374"></a>
<FONT color="green">375</FONT>            return "dateCreated";<a name="line.375"></a>
<FONT color="green">376</FONT>        }<a name="line.376"></a>
<FONT color="green">377</FONT>    <a name="line.377"></a>
<FONT color="green">378</FONT>    <a name="line.378"></a>
<FONT color="green">379</FONT>    <a name="line.379"></a>
<FONT color="green">380</FONT>        /**<a name="line.380"></a>
<FONT color="green">381</FONT>         * Returns the name to use for the standard "date modified" system column.  Subclasses can override this to use a different name.<a name="line.381"></a>
<FONT color="green">382</FONT>         *<a name="line.382"></a>
<FONT color="green">383</FONT>         * @return  the name to use for the standard "date modified" system column.<a name="line.383"></a>
<FONT color="green">384</FONT>         */<a name="line.384"></a>
<FONT color="green">385</FONT>        public String dateModifiedColumnName()<a name="line.385"></a>
<FONT color="green">386</FONT>        {<a name="line.386"></a>
<FONT color="green">387</FONT>            return "dateModified";<a name="line.387"></a>
<FONT color="green">388</FONT>        }<a name="line.388"></a>
<FONT color="green">389</FONT>    <a name="line.389"></a>
<FONT color="green">390</FONT>    <a name="line.390"></a>
<FONT color="green">391</FONT>    <a name="line.391"></a>
<FONT color="green">392</FONT>        /**<a name="line.392"></a>
<FONT color="green">393</FONT>         * Returns an ordered list of columns from this Table which may be used in the formula of a calculated column.<a name="line.393"></a>
<FONT color="green">394</FONT>         *<a name="line.394"></a>
<FONT color="green">395</FONT>         * @return an ordered list of columns from this Table which may be used in the formula of a calculated column<a name="line.395"></a>
<FONT color="green">396</FONT>         */<a name="line.396"></a>
<FONT color="green">397</FONT>        public NSArray columnsAvailableForCalculation()<a name="line.397"></a>
<FONT color="green">398</FONT>        {<a name="line.398"></a>
<FONT color="green">399</FONT>            NSMutableArray columnsAvailableForCalculation = new NSMutableArray();<a name="line.399"></a>
<FONT color="green">400</FONT>            Enumeration columnEnumerator = orderedColumns().objectEnumerator();<a name="line.400"></a>
<FONT color="green">401</FONT>            while (columnEnumerator.hasMoreElements())<a name="line.401"></a>
<FONT color="green">402</FONT>            {<a name="line.402"></a>
<FONT color="green">403</FONT>                VirtualColumn aColumn = (VirtualColumn) columnEnumerator.nextElement();<a name="line.403"></a>
<FONT color="green">404</FONT>    <a name="line.404"></a>
<FONT color="green">405</FONT>                if (VirtualCalculatedColumn.canUseColumnInCalculation(aColumn))<a name="line.405"></a>
<FONT color="green">406</FONT>                {<a name="line.406"></a>
<FONT color="green">407</FONT>                    columnsAvailableForCalculation.addObject(aColumn);<a name="line.407"></a>
<FONT color="green">408</FONT>                }<a name="line.408"></a>
<FONT color="green">409</FONT>            }<a name="line.409"></a>
<FONT color="green">410</FONT>    <a name="line.410"></a>
<FONT color="green">411</FONT>            return columnsAvailableForCalculation;<a name="line.411"></a>
<FONT color="green">412</FONT>            /** ensure [valid_result] Result != null;  **/<a name="line.412"></a>
<FONT color="green">413</FONT>        }<a name="line.413"></a>
<FONT color="green">414</FONT>    <a name="line.414"></a>
<FONT color="green">415</FONT>    <a name="line.415"></a>
<FONT color="green">416</FONT>    <a name="line.416"></a>
<FONT color="green">417</FONT>        /**<a name="line.417"></a>
<FONT color="green">418</FONT>         * Updates statement to hold SQL to delete all the rows in this virtual table.<a name="line.418"></a>
<FONT color="green">419</FONT>         *<a name="line.419"></a>
<FONT color="green">420</FONT>         * @param batchStatement the batch of statements to which this will add it's SQL<a name="line.420"></a>
<FONT color="green">421</FONT>         */<a name="line.421"></a>
<FONT color="green">422</FONT>        public void batchDeleteRows(Statement batchStatement) throws SQLException<a name="line.422"></a>
<FONT color="green">423</FONT>        {<a name="line.423"></a>
<FONT color="green">424</FONT>            /** require [valid_param] batchStatement != null; **/<a name="line.424"></a>
<FONT color="green">425</FONT>    <a name="line.425"></a>
<FONT color="green">426</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.426"></a>
<FONT color="green">427</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.427"></a>
<FONT color="green">428</FONT>    <a name="line.428"></a>
<FONT color="green">429</FONT>            // No need to lock dbContext as this is called in the context of a locked co-ordinator<a name="line.429"></a>
<FONT color="green">430</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, editingContext());<a name="line.430"></a>
<FONT color="green">431</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.431"></a>
<FONT color="green">432</FONT>            EOEntity vrEntity = EOModelGroup.defaultGroup().entityNamed("VirtualRow");<a name="line.432"></a>
<FONT color="green">433</FONT>            /** check [has_vrEntity] vrEntity != null; **/<a name="line.433"></a>
<FONT color="green">434</FONT>            EOEntity vfEntity = EOModelGroup.defaultGroup().entityNamed("VirtualField");<a name="line.434"></a>
<FONT color="green">435</FONT>            /** check [has_vfEntity] vfEntity != null; **/<a name="line.435"></a>
<FONT color="green">436</FONT>            JDBCContext adContext = (JDBCContext)dbContext.adaptorContext();<a name="line.436"></a>
<FONT color="green">437</FONT>            EOAdaptor adaptor = adContext.adaptor();<a name="line.437"></a>
<FONT color="green">438</FONT>            Enumeration rowEnumerator = rows().objectEnumerator();<a name="line.438"></a>
<FONT color="green">439</FONT>    <a name="line.439"></a>
<FONT color="green">440</FONT>            while (rowEnumerator.hasMoreElements())<a name="line.440"></a>
<FONT color="green">441</FONT>            {<a name="line.441"></a>
<FONT color="green">442</FONT>                VirtualRow row = (VirtualRow)rowEnumerator.nextElement();<a name="line.442"></a>
<FONT color="green">443</FONT>    <a name="line.443"></a>
<FONT color="green">444</FONT>                EOQualifier qualifier = EOQualifier.qualifierWithQualifierFormat("virtualRowID = %@", new NSArray(row.virtualRowID()));<a name="line.444"></a>
<FONT color="green">445</FONT>                EOSQLExpression expression = new EOSQLExpressionFactory(adaptor).deleteStatementWithQualifier(qualifier, vfEntity);<a name="line.445"></a>
<FONT color="green">446</FONT>                System.out.println("Batching statement: " + expression.statement());<a name="line.446"></a>
<FONT color="green">447</FONT>                batchStatement.addBatch(expression.statement());<a name="line.447"></a>
<FONT color="green">448</FONT>            }<a name="line.448"></a>
<FONT color="green">449</FONT>    <a name="line.449"></a>
<FONT color="green">450</FONT>            EOQualifier qualifier = EOQualifier.qualifierWithQualifierFormat("virtualTableID = %@", new NSArray(tableID()));<a name="line.450"></a>
<FONT color="green">451</FONT>            EOSQLExpression expression = new EOSQLExpressionFactory(adaptor).deleteStatementWithQualifier(qualifier, vrEntity);<a name="line.451"></a>
<FONT color="green">452</FONT>            System.out.println("Batching statement: " + expression.statement());<a name="line.452"></a>
<FONT color="green">453</FONT>            batchStatement.addBatch(expression.statement());<a name="line.453"></a>
<FONT color="green">454</FONT>        }<a name="line.454"></a>
<FONT color="green">455</FONT>    <a name="line.455"></a>
<FONT color="green">456</FONT>    <a name="line.456"></a>
<FONT color="green">457</FONT>        /**<a name="line.457"></a>
<FONT color="green">458</FONT>         * Deletes all the rows in this virtual table. This maximizes delete speed by not using WO at all, instead talking directly to the JDBC adaptor to delete.<a name="line.458"></a>
<FONT color="green">459</FONT>         */<a name="line.459"></a>
<FONT color="green">460</FONT>        public void deleteRows()<a name="line.460"></a>
<FONT color="green">461</FONT>        {<a name="line.461"></a>
<FONT color="green">462</FONT>            /** require [no_changes_on_table] ! editingContext().hasChanges(); **/<a name="line.462"></a>
<FONT color="green">463</FONT>    <a name="line.463"></a>
<FONT color="green">464</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.464"></a>
<FONT color="green">465</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.465"></a>
<FONT color="green">466</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, editingContext());<a name="line.466"></a>
<FONT color="green">467</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.467"></a>
<FONT color="green">468</FONT>    <a name="line.468"></a>
<FONT color="green">469</FONT>            dbContext.coordinator().lock();<a name="line.469"></a>
<FONT color="green">470</FONT>            try<a name="line.470"></a>
<FONT color="green">471</FONT>            {<a name="line.471"></a>
<FONT color="green">472</FONT>                JDBCContext adaptorContext = (JDBCContext)dbContext.adaptorContext();<a name="line.472"></a>
<FONT color="green">473</FONT>                java.sql.Connection connection = adaptorContext.connection();<a name="line.473"></a>
<FONT color="green">474</FONT>    <a name="line.474"></a>
<FONT color="green">475</FONT>                try<a name="line.475"></a>
<FONT color="green">476</FONT>                {<a name="line.476"></a>
<FONT color="green">477</FONT>                    Statement statement = connection.createStatement();<a name="line.477"></a>
<FONT color="green">478</FONT>                    batchDeleteRows(statement);<a name="line.478"></a>
<FONT color="green">479</FONT>                    statement.executeBatch();<a name="line.479"></a>
<FONT color="green">480</FONT>                    connection.commit();<a name="line.480"></a>
<FONT color="green">481</FONT>                }<a name="line.481"></a>
<FONT color="green">482</FONT>                catch (SQLException e)<a name="line.482"></a>
<FONT color="green">483</FONT>                {<a name="line.483"></a>
<FONT color="green">484</FONT>                    try<a name="line.484"></a>
<FONT color="green">485</FONT>                    {<a name="line.485"></a>
<FONT color="green">486</FONT>                        connection.rollback();<a name="line.486"></a>
<FONT color="green">487</FONT>                    }<a name="line.487"></a>
<FONT color="green">488</FONT>                    catch (SQLException x) { }<a name="line.488"></a>
<FONT color="green">489</FONT>                    throw new ExceptionConverter(e);<a name="line.489"></a>
<FONT color="green">490</FONT>                }<a name="line.490"></a>
<FONT color="green">491</FONT>    <a name="line.491"></a>
<FONT color="green">492</FONT>                refreshTableData();<a name="line.492"></a>
<FONT color="green">493</FONT>            }<a name="line.493"></a>
<FONT color="green">494</FONT>            finally<a name="line.494"></a>
<FONT color="green">495</FONT>            {<a name="line.495"></a>
<FONT color="green">496</FONT>                dbContext.coordinator().unlock();<a name="line.496"></a>
<FONT color="green">497</FONT>            }<a name="line.497"></a>
<FONT color="green">498</FONT>    <a name="line.498"></a>
<FONT color="green">499</FONT>            /** ensure [has_no_rows] rows().count() == 0; **/<a name="line.499"></a>
<FONT color="green">500</FONT>        }<a name="line.500"></a>
<FONT color="green">501</FONT>    <a name="line.501"></a>
<FONT color="green">502</FONT>    <a name="line.502"></a>
<FONT color="green">503</FONT>        /**<a name="line.503"></a>
<FONT color="green">504</FONT>         * This method should be called after direct SQL manipulation of the data in this table (i.e. importing data or deleting rows).  The data will have been modified in the database, but EOF doesn't know about that. Make EOF refault the table and its columns so that the relationships referring to these directly modifed objects get reloaded.<a name="line.504"></a>
<FONT color="green">505</FONT>         */<a name="line.505"></a>
<FONT color="green">506</FONT>        public void refreshTableData()<a name="line.506"></a>
<FONT color="green">507</FONT>        {<a name="line.507"></a>
<FONT color="green">508</FONT>            NSMutableArray invalidObjects = new NSMutableArray(editingContext().globalIDForObject(this));<a name="line.508"></a>
<FONT color="green">509</FONT>            invalidObjects.addObjectsFromArray(EOEditingContextAdditions.globalIDsForObjects(editingContext(), columns()));<a name="line.509"></a>
<FONT color="green">510</FONT>            editingContext().invalidateObjectsWithGlobalIDs(invalidObjects);<a name="line.510"></a>
<FONT color="green">511</FONT>        }<a name="line.511"></a>
<FONT color="green">512</FONT>    <a name="line.512"></a>
<FONT color="green">513</FONT>    <a name="line.513"></a>
<FONT color="green">514</FONT>    <a name="line.514"></a>
<FONT color="green">515</FONT>        /**<a name="line.515"></a>
<FONT color="green">516</FONT>         * Appends or replaces rows to the table from the given stream.  The stream must contain character data in &lt;code&gt;delimiter&lt;/code&gt; delimited format.  Note: right now, this method doesn't handle quoted data or anything fancy.  Also note that this method requires that the table has no changes on it...  call &lt;code&gt;saveChanges()&lt;/code&gt; before using this.<a name="line.516"></a>
<FONT color="green">517</FONT>         *<a name="line.517"></a>
<FONT color="green">518</FONT>         * @param stream the stream of characters that will make up the new rows.  The stream is &lt;em&gt;not&lt;/em&gt; closed at the end of this method - you'll have to do it yourself<a name="line.518"></a>
<FONT color="green">519</FONT>         * @param sender an arbitrary object that is used as a parameter to Column's valueForImportedValue() method<a name="line.519"></a>
<FONT color="green">520</FONT>         * @param columnsToImport an ordered list of columns that we will import.  The first item in this array cooresponds to the first field in the data file, the second item to the second field, and so on<a name="line.520"></a>
<FONT color="green">521</FONT>         * @param formatters mapping of column names to java.text.Formats, used to format the field strings into objects of the correct type. You'll normally only need this for date/times and possibly for custom column types<a name="line.521"></a>
<FONT color="green">522</FONT>         * @param delimiter the character to use as the delimiter<a name="line.522"></a>
<FONT color="green">523</FONT>         * @param skipFirstLine should we skip the first line? Useful if, for example, the first line contains the column names<a name="line.523"></a>
<FONT color="green">524</FONT>         * @param shouldReplace &lt;code&gt;true&lt;/code&gt; if this should replace all the rows, &lt;code&gt;false&lt;/code&gt; if it should append the rows<a name="line.524"></a>
<FONT color="green">525</FONT>         * @exception IOException occurs when an IO exception occurs on the steam<a name="line.525"></a>
<FONT color="green">526</FONT>         * @exception ParseException occurs when a formatter cannot format the data given it<a name="line.526"></a>
<FONT color="green">527</FONT>         */<a name="line.527"></a>
<FONT color="green">528</FONT>        public void importTable(InputStream stream,<a name="line.528"></a>
<FONT color="green">529</FONT>                                Object sender,<a name="line.529"></a>
<FONT color="green">530</FONT>                                NSArray columnsToImport,<a name="line.530"></a>
<FONT color="green">531</FONT>                                NSDictionary formatters,<a name="line.531"></a>
<FONT color="green">532</FONT>                                String delimiter,<a name="line.532"></a>
<FONT color="green">533</FONT>                                boolean skipFirstLine,<a name="line.533"></a>
<FONT color="green">534</FONT>                                boolean shouldReplace)<a name="line.534"></a>
<FONT color="green">535</FONT>            throws IOException, ParseException<a name="line.535"></a>
<FONT color="green">536</FONT>        {<a name="line.536"></a>
<FONT color="green">537</FONT>            /** require<a name="line.537"></a>
<FONT color="green">538</FONT>            [valid_stream_param] stream != null;<a name="line.538"></a>
<FONT color="green">539</FONT>            [valid_columnsToImport_param] columnsToImport != null;<a name="line.539"></a>
<FONT color="green">540</FONT>            [has_columns_to_import] columnsToImport.count() &gt; 0;<a name="line.540"></a>
<FONT color="green">541</FONT>            [columns_refer_to_same_table] forall i : {0 .. columnsToImport.count() - 1} # ((Column)columnsToImport.objectAtIndex(i)).table().equals(((Column)columnsToImport.objectAtIndex(0)).table());<a name="line.541"></a>
<FONT color="green">542</FONT>            [columns_are_importable] forall i : {0 .. columnsToImport.count() - 1} # ColumnType.validImportTypes().containsObject(((Column)columnsToImport.objectAtIndex(i)).type().name());<a name="line.542"></a>
<FONT color="green">543</FONT>            [valid_formatters_param] formatters != null;<a name="line.543"></a>
<FONT color="green">544</FONT>            [valid_delimiter_param] delimiter != null;<a name="line.544"></a>
<FONT color="green">545</FONT>            [same_number_of_columns] /# Does the import data have the same number of columns as the columnsToImport? #/ true;<a name="line.545"></a>
<FONT color="green">546</FONT>            [no_changes_on_table] ! editingContext().hasChanges(); **/<a name="line.546"></a>
<FONT color="green">547</FONT>    <a name="line.547"></a>
<FONT color="green">548</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.548"></a>
<FONT color="green">549</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.549"></a>
<FONT color="green">550</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, editingContext());<a name="line.550"></a>
<FONT color="green">551</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.551"></a>
<FONT color="green">552</FONT>    <a name="line.552"></a>
<FONT color="green">553</FONT>            dbContext.coordinator().lock();<a name="line.553"></a>
<FONT color="green">554</FONT>            try<a name="line.554"></a>
<FONT color="green">555</FONT>            {<a name="line.555"></a>
<FONT color="green">556</FONT>                JDBCContext adaptorContext = (JDBCContext)dbContext.adaptorContext();<a name="line.556"></a>
<FONT color="green">557</FONT>                java.sql.Connection connection = adaptorContext.connection();<a name="line.557"></a>
<FONT color="green">558</FONT>    <a name="line.558"></a>
<FONT color="green">559</FONT>                try<a name="line.559"></a>
<FONT color="green">560</FONT>                {<a name="line.560"></a>
<FONT color="green">561</FONT>                    if (shouldReplace)<a name="line.561"></a>
<FONT color="green">562</FONT>                    {<a name="line.562"></a>
<FONT color="green">563</FONT>                        Statement statement = connection.createStatement();<a name="line.563"></a>
<FONT color="green">564</FONT>                        batchDeleteRows(statement);<a name="line.564"></a>
<FONT color="green">565</FONT>                        statement.executeBatch();<a name="line.565"></a>
<FONT color="green">566</FONT>                    }<a name="line.566"></a>
<FONT color="green">567</FONT>    <a name="line.567"></a>
<FONT color="green">568</FONT>                    // Read the file in the same ecoding that we exported it in.<a name="line.568"></a>
<FONT color="green">569</FONT>                    BufferedReader reader = new BufferedReader(new InputStreamReader(stream, STRING_ENCODING));<a name="line.569"></a>
<FONT color="green">570</FONT>                    String oneLine;<a name="line.570"></a>
<FONT color="green">571</FONT>                    while ((oneLine = reader.readLine()) != null)<a name="line.571"></a>
<FONT color="green">572</FONT>                    {<a name="line.572"></a>
<FONT color="green">573</FONT>                        if (skipFirstLine)<a name="line.573"></a>
<FONT color="green">574</FONT>                        {<a name="line.574"></a>
<FONT color="green">575</FONT>                            skipFirstLine = false;<a name="line.575"></a>
<FONT color="green">576</FONT>                        }<a name="line.576"></a>
<FONT color="green">577</FONT>                        else<a name="line.577"></a>
<FONT color="green">578</FONT>                        {<a name="line.578"></a>
<FONT color="green">579</FONT>                            // My testing indicates that it is faster (by more than 5x for larger imports) to execute statements in smaller chunks (like, say, per virtual row)<a name="line.579"></a>
<FONT color="green">580</FONT>                            Statement statement = connection.createStatement();<a name="line.580"></a>
<FONT color="green">581</FONT>    <a name="line.581"></a>
<FONT color="green">582</FONT>                            //** check [same_number_of_columns] dataElements.count() == columnsToImport.count(); **/<a name="line.582"></a>
<FONT color="green">583</FONT>                            DelimitedStringTokenizer tokenizer = new DelimitedStringTokenizer(oneLine, delimiter, "'\"", null);<a name="line.583"></a>
<FONT color="green">584</FONT>    <a name="line.584"></a>
<FONT color="green">585</FONT>                            Object rowID = batchNewRow(sender, statement);<a name="line.585"></a>
<FONT color="green">586</FONT>                            for (int i = 0; i &lt; columnsToImport.count(); i++)<a name="line.586"></a>
<FONT color="green">587</FONT>                            {<a name="line.587"></a>
<FONT color="green">588</FONT>                                Column column = (Column)columnsToImport.objectAtIndex(i);<a name="line.588"></a>
<FONT color="green">589</FONT>                                Object dataElement = tokenizer.nextToken();<a name="line.589"></a>
<FONT color="green">590</FONT>    <a name="line.590"></a>
<FONT color="green">591</FONT>                                // dataElement can be null or an empty string "", and we don't want empty or null values in our table<a name="line.591"></a>
<FONT color="green">592</FONT>                                if ((dataElement != null) &amp;&amp; ( ! dataElement.equals("")))<a name="line.592"></a>
<FONT color="green">593</FONT>                                {<a name="line.593"></a>
<FONT color="green">594</FONT>                                    Format formatter = (Format)formatters.objectForKey(column.name());<a name="line.594"></a>
<FONT color="green">595</FONT>                                    if (formatter != null)<a name="line.595"></a>
<FONT color="green">596</FONT>                                    {<a name="line.596"></a>
<FONT color="green">597</FONT>                                        dataElement = formatter.parseObject((String)dataElement);<a name="line.597"></a>
<FONT color="green">598</FONT>                                    }<a name="line.598"></a>
<FONT color="green">599</FONT>    <a name="line.599"></a>
<FONT color="green">600</FONT>                                    dataElement = column.valueForImportedValue(sender, dataElement);<a name="line.600"></a>
<FONT color="green">601</FONT>    <a name="line.601"></a>
<FONT color="green">602</FONT>                                    // valueForImportedValue can return null to indicate that the value should not be imported<a name="line.602"></a>
<FONT color="green">603</FONT>                                    if (dataElement != null)<a name="line.603"></a>
<FONT color="green">604</FONT>                                    {<a name="line.604"></a>
<FONT color="green">605</FONT>                                        batchNewField(statement, rowID, column, dataElement);<a name="line.605"></a>
<FONT color="green">606</FONT>                                    }<a name="line.606"></a>
<FONT color="green">607</FONT>                                }<a name="line.607"></a>
<FONT color="green">608</FONT>                            }<a name="line.608"></a>
<FONT color="green">609</FONT>                            /** check [nothing_left_to_tokenize] ! tokenizer.hasMoreTokens(); **/<a name="line.609"></a>
<FONT color="green">610</FONT>    <a name="line.610"></a>
<FONT color="green">611</FONT>                            System.out.println("BATCH: " + statement);<a name="line.611"></a>
<FONT color="green">612</FONT>                            statement.executeBatch();<a name="line.612"></a>
<FONT color="green">613</FONT>                        }<a name="line.613"></a>
<FONT color="green">614</FONT>                    }<a name="line.614"></a>
<FONT color="green">615</FONT>    <a name="line.615"></a>
<FONT color="green">616</FONT>                    connection.commit();<a name="line.616"></a>
<FONT color="green">617</FONT>                }<a name="line.617"></a>
<FONT color="green">618</FONT>                catch (SQLException e)<a name="line.618"></a>
<FONT color="green">619</FONT>                {<a name="line.619"></a>
<FONT color="green">620</FONT>                    try<a name="line.620"></a>
<FONT color="green">621</FONT>                    {<a name="line.621"></a>
<FONT color="green">622</FONT>                        connection.rollback();<a name="line.622"></a>
<FONT color="green">623</FONT>                    }<a name="line.623"></a>
<FONT color="green">624</FONT>                    catch (SQLException x) { }<a name="line.624"></a>
<FONT color="green">625</FONT>                    throw new ExceptionConverter(e);<a name="line.625"></a>
<FONT color="green">626</FONT>                }<a name="line.626"></a>
<FONT color="green">627</FONT>    <a name="line.627"></a>
<FONT color="green">628</FONT>                refreshTableData();<a name="line.628"></a>
<FONT color="green">629</FONT>            }<a name="line.629"></a>
<FONT color="green">630</FONT>            finally<a name="line.630"></a>
<FONT color="green">631</FONT>            {<a name="line.631"></a>
<FONT color="green">632</FONT>                dbContext.coordinator().unlock();<a name="line.632"></a>
<FONT color="green">633</FONT>            }<a name="line.633"></a>
<FONT color="green">634</FONT>        }<a name="line.634"></a>
<FONT color="green">635</FONT>    <a name="line.635"></a>
<FONT color="green">636</FONT>    <a name="line.636"></a>
<FONT color="green">637</FONT>    <a name="line.637"></a>
<FONT color="green">638</FONT>        /**<a name="line.638"></a>
<FONT color="green">639</FONT>         * Adds a new virtual row to the given batch statement. This maximizes insert speed by not using WO at all, instead talking directly to the JDBC adaptor (through a Statement) to insert.  Also inserts the two system fields.<a name="line.639"></a>
<FONT color="green">640</FONT>         *<a name="line.640"></a>
<FONT color="green">641</FONT>         * @param sender an arbitrary object that is used as a parameter to Column's valueForImportedValue() method<a name="line.641"></a>
<FONT color="green">642</FONT>         * @param batchStatement the batch of statements to which this will add it's SQL<a name="line.642"></a>
<FONT color="green">643</FONT>         * @return the newly created and inserted row's PK<a name="line.643"></a>
<FONT color="green">644</FONT>         */<a name="line.644"></a>
<FONT color="green">645</FONT>        public Object batchNewRow(Object sender, Statement batchStatement) throws SQLException<a name="line.645"></a>
<FONT color="green">646</FONT>        {<a name="line.646"></a>
<FONT color="green">647</FONT>            /** require<a name="line.647"></a>
<FONT color="green">648</FONT>            [valid_param] batchStatement != null; **/<a name="line.648"></a>
<FONT color="green">649</FONT>    <a name="line.649"></a>
<FONT color="green">650</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.650"></a>
<FONT color="green">651</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.651"></a>
<FONT color="green">652</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, editingContext());<a name="line.652"></a>
<FONT color="green">653</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.653"></a>
<FONT color="green">654</FONT>    <a name="line.654"></a>
<FONT color="green">655</FONT>            dbContext.coordinator().lock();<a name="line.655"></a>
<FONT color="green">656</FONT>            try<a name="line.656"></a>
<FONT color="green">657</FONT>            {<a name="line.657"></a>
<FONT color="green">658</FONT>                EOEntity entity = EOModelGroup.defaultGroup().entityNamed("VirtualRow");<a name="line.658"></a>
<FONT color="green">659</FONT>                /** check [has_entity] entity != null; **/<a name="line.659"></a>
<FONT color="green">660</FONT>    <a name="line.660"></a>
<FONT color="green">661</FONT>                Object rowID;<a name="line.661"></a>
<FONT color="green">662</FONT>                if (Table.isUsingIntegerPKs())<a name="line.662"></a>
<FONT color="green">663</FONT>                {<a name="line.663"></a>
<FONT color="green">664</FONT>                    rowID = pkGenerator.databaseContextNewPrimaryKey(dbContext, null, entity).objectForKey("virtualRowID");<a name="line.664"></a>
<FONT color="green">665</FONT>                }<a name="line.665"></a>
<FONT color="green">666</FONT>                else<a name="line.666"></a>
<FONT color="green">667</FONT>                {<a name="line.667"></a>
<FONT color="green">668</FONT>                    EOAdaptorChannel adaptorChannel = dbContext.availableChannel().adaptorChannel();<a name="line.668"></a>
<FONT color="green">669</FONT>                    if (!adaptorChannel.isOpen())<a name="line.669"></a>
<FONT color="green">670</FONT>                    {<a name="line.670"></a>
<FONT color="green">671</FONT>                        adaptorChannel.openChannel();<a name="line.671"></a>
<FONT color="green">672</FONT>                    }<a name="line.672"></a>
<FONT color="green">673</FONT>                    NSDictionary pk = (NSDictionary) adaptorChannel.primaryKeysForNewRowsWithEntity(1, entity).lastObject();<a name="line.673"></a>
<FONT color="green">674</FONT>                    rowID = pk.allValues().lastObject();<a name="line.674"></a>
<FONT color="green">675</FONT>                }<a name="line.675"></a>
<FONT color="green">676</FONT>                NSMutableDictionary valueDictionary = new NSMutableDictionary();<a name="line.676"></a>
<FONT color="green">677</FONT>                valueDictionary.setObjectForKey(rowID, "virtualRowID");<a name="line.677"></a>
<FONT color="green">678</FONT>                valueDictionary.setObjectForKey(tableID(), "virtualTableID");<a name="line.678"></a>
<FONT color="green">679</FONT>    <a name="line.679"></a>
<FONT color="green">680</FONT>                JDBCContext adContext = (JDBCContext)dbContext.adaptorContext();<a name="line.680"></a>
<FONT color="green">681</FONT>                EOAdaptor adaptor = adContext.adaptor();<a name="line.681"></a>
<FONT color="green">682</FONT>                EOSQLExpression expression = new EOSQLExpressionFactory(adaptor).insertStatementForRow(valueDictionary, entity);<a name="line.682"></a>
<FONT color="green">683</FONT>                System.out.println("Batching statement: " + expression.statement());<a name="line.683"></a>
<FONT color="green">684</FONT>                batchStatement.addBatch(expression.statement());<a name="line.684"></a>
<FONT color="green">685</FONT>    <a name="line.685"></a>
<FONT color="green">686</FONT>                // Create the "system" fields<a name="line.686"></a>
<FONT color="green">687</FONT>                Column column = columnNamed(dateCreatedColumnName());<a name="line.687"></a>
<FONT color="green">688</FONT>                batchNewField(batchStatement, rowID, column, column.valueForImportedValue(sender, Date.now()));<a name="line.688"></a>
<FONT color="green">689</FONT>                column = columnNamed(dateModifiedColumnName());<a name="line.689"></a>
<FONT color="green">690</FONT>                batchNewField(batchStatement, rowID, column, column.valueForImportedValue(sender, Date.now()));<a name="line.690"></a>
<FONT color="green">691</FONT>    <a name="line.691"></a>
<FONT color="green">692</FONT>                return rowID;<a name="line.692"></a>
<FONT color="green">693</FONT>            }<a name="line.693"></a>
<FONT color="green">694</FONT>            finally<a name="line.694"></a>
<FONT color="green">695</FONT>            {<a name="line.695"></a>
<FONT color="green">696</FONT>                dbContext.coordinator().unlock();<a name="line.696"></a>
<FONT color="green">697</FONT>            }<a name="line.697"></a>
<FONT color="green">698</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.698"></a>
<FONT color="green">699</FONT>        }<a name="line.699"></a>
<FONT color="green">700</FONT>    <a name="line.700"></a>
<FONT color="green">701</FONT>    <a name="line.701"></a>
<FONT color="green">702</FONT>        /**<a name="line.702"></a>
<FONT color="green">703</FONT>         * Adds a new virtual field to the given batch statement. This maximizes insert speed by not using WO at all, instead talking directly to the JDBC adaptor (through a Statement) to insert.<a name="line.703"></a>
<FONT color="green">704</FONT>         *<a name="line.704"></a>
<FONT color="green">705</FONT>         * @param batchStatement the batch of statements to which this will add it's SQL<a name="line.705"></a>
<FONT color="green">706</FONT>         * @param column the column that this field applies to<a name="line.706"></a>
<FONT color="green">707</FONT>         * @param rowID the row that this field applies to<a name="line.707"></a>
<FONT color="green">708</FONT>         * @param value the value of the field.  The value should be coerced with Column's valueForImportedValue() before calling this<a name="line.708"></a>
<FONT color="green">709</FONT>         * @return the newly created and inserted field's PK<a name="line.709"></a>
<FONT color="green">710</FONT>         */<a name="line.710"></a>
<FONT color="green">711</FONT>        public Object batchNewField(Statement batchStatement, Object rowID, Column column, Object value) throws SQLException<a name="line.711"></a>
<FONT color="green">712</FONT>        {<a name="line.712"></a>
<FONT color="green">713</FONT>            /** require<a name="line.713"></a>
<FONT color="green">714</FONT>            [valid_batchStatement_param] batchStatement != null;<a name="line.714"></a>
<FONT color="green">715</FONT>            [valid_column_param] column != null;<a name="line.715"></a>
<FONT color="green">716</FONT>            [column_has_permanent_globalID] ! editingContext().globalIDForObject(column).isTemporary();<a name="line.716"></a>
<FONT color="green">717</FONT>            [valid_rowID_param] rowID != null; **/<a name="line.717"></a>
<FONT color="green">718</FONT>    <a name="line.718"></a>
<FONT color="green">719</FONT>            EOModel vtModel = EOModelGroup.defaultGroup().modelNamed("VirtualTables");<a name="line.719"></a>
<FONT color="green">720</FONT>            /** check [has_eomodel] vtModel != null; **/<a name="line.720"></a>
<FONT color="green">721</FONT>            // No need to lock dbContext as this method called in the context of a locked co-ordinator<a name="line.721"></a>
<FONT color="green">722</FONT>            EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(vtModel, editingContext());<a name="line.722"></a>
<FONT color="green">723</FONT>            /** check [has_dbcontext] dbContext != null; **/<a name="line.723"></a>
<FONT color="green">724</FONT>            String columnTypeName = column.type().name();<a name="line.724"></a>
<FONT color="green">725</FONT>            EOEntity entity = EOModelGroup.defaultGroup().entityNamed("Virtual" + columnTypeName + "Field");<a name="line.725"></a>
<FONT color="green">726</FONT>            /** check [has_entity] entity != null; **/<a name="line.726"></a>
<FONT color="green">727</FONT>    <a name="line.727"></a>
<FONT color="green">728</FONT>            NSMutableDictionary valueDictionary = new NSMutableDictionary();<a name="line.728"></a>
<FONT color="green">729</FONT>            Object fieldID;<a name="line.729"></a>
<FONT color="green">730</FONT>            if (Table.isUsingIntegerPKs())<a name="line.730"></a>
<FONT color="green">731</FONT>            {<a name="line.731"></a>
<FONT color="green">732</FONT>                fieldID = pkGenerator.databaseContextNewPrimaryKey(dbContext, null, entity).valueForKey("virtualFieldID");<a name="line.732"></a>
<FONT color="green">733</FONT>            }<a name="line.733"></a>
<FONT color="green">734</FONT>            else<a name="line.734"></a>
<FONT color="green">735</FONT>            {<a name="line.735"></a>
<FONT color="green">736</FONT>                EOAdaptorChannel adaptorChannel = dbContext.availableChannel().adaptorChannel();<a name="line.736"></a>
<FONT color="green">737</FONT>                if (!adaptorChannel.isOpen())<a name="line.737"></a>
<FONT color="green">738</FONT>                {<a name="line.738"></a>
<FONT color="green">739</FONT>                    adaptorChannel.openChannel();<a name="line.739"></a>
<FONT color="green">740</FONT>                }<a name="line.740"></a>
<FONT color="green">741</FONT>                NSDictionary pk = (NSDictionary) adaptorChannel.primaryKeysForNewRowsWithEntity(1, entity).lastObject();<a name="line.741"></a>
<FONT color="green">742</FONT>                fieldID = pk.allValues().lastObject();<a name="line.742"></a>
<FONT color="green">743</FONT>                System.out.println("Batching field for fieldID: " + ERXStringUtilities.byteArrayToHexString(((NSData)fieldID).bytes()));<a name="line.743"></a>
<FONT color="green">744</FONT>            }<a name="line.744"></a>
<FONT color="green">745</FONT>    <a name="line.745"></a>
<FONT color="green">746</FONT>            valueDictionary.setObjectForKey(fieldID, "virtualFieldID");<a name="line.746"></a>
<FONT color="green">747</FONT>            valueDictionary.setObjectForKey(rowID, "virtualRowID");<a name="line.747"></a>
<FONT color="green">748</FONT>            NSDictionary columnPK = EOUtilities.primaryKeyForObject(column.editingContext(), column);<a name="line.748"></a>
<FONT color="green">749</FONT>            valueDictionary.setObjectForKey(columnPK.objectForKey("columnID"), "virtualColumnID");<a name="line.749"></a>
<FONT color="green">750</FONT>            valueDictionary.setObjectForKey(columnTypeName, "restrictingValue");<a name="line.750"></a>
<FONT color="green">751</FONT>    <a name="line.751"></a>
<FONT color="green">752</FONT>            valueDictionary.setObjectForKey(value, column.importAttributeName());<a name="line.752"></a>
<FONT color="green">753</FONT>    <a name="line.753"></a>
<FONT color="green">754</FONT>            JDBCContext adContext = (JDBCContext)dbContext.adaptorContext();<a name="line.754"></a>
<FONT color="green">755</FONT>            EOAdaptor adaptor = adContext.adaptor();<a name="line.755"></a>
<FONT color="green">756</FONT>            EOSQLExpression expression = new EOSQLExpressionFactory(adaptor).insertStatementForRow(valueDictionary, entity);<a name="line.756"></a>
<FONT color="green">757</FONT>            System.out.println("Batching statement: " + expression.statement());<a name="line.757"></a>
<FONT color="green">758</FONT>            batchStatement.addBatch(expression.statement());<a name="line.758"></a>
<FONT color="green">759</FONT>    <a name="line.759"></a>
<FONT color="green">760</FONT>            return fieldID;<a name="line.760"></a>
<FONT color="green">761</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.761"></a>
<FONT color="green">762</FONT>        }<a name="line.762"></a>
<FONT color="green">763</FONT>    <a name="line.763"></a>
<FONT color="green">764</FONT>    <a name="line.764"></a>
<FONT color="green">765</FONT>    <a name="line.765"></a>
<FONT color="green">766</FONT>        /**<a name="line.766"></a>
<FONT color="green">767</FONT>         * Changes EOL strings ("\r\n", "\r", "\n") in &lt;code&gt;aString&lt;/code&gt; to a space.<a name="line.767"></a>
<FONT color="green">768</FONT>         *<a name="line.768"></a>
<FONT color="green">769</FONT>         * @param aString the string in which to change EOL characters to spaces<a name="line.769"></a>
<FONT color="green">770</FONT>         * @return the newly created and inserted field's PK<a name="line.770"></a>
<FONT color="green">771</FONT>         */<a name="line.771"></a>
<FONT color="green">772</FONT>        public String mungeEOLCharacters(String aString)<a name="line.772"></a>
<FONT color="green">773</FONT>        {<a name="line.773"></a>
<FONT color="green">774</FONT>            /** require [valid_param] aString != null; **/<a name="line.774"></a>
<FONT color="green">775</FONT>    <a name="line.775"></a>
<FONT color="green">776</FONT>            StringBuffer stringBuffer = new StringBuffer(aString);<a name="line.776"></a>
<FONT color="green">777</FONT>            for (int i = 0; i &lt; stringBuffer.length(); i++)<a name="line.777"></a>
<FONT color="green">778</FONT>            {<a name="line.778"></a>
<FONT color="green">779</FONT>                char aChar = stringBuffer.charAt(i);<a name="line.779"></a>
<FONT color="green">780</FONT>                if ((aChar == '\n') || (aChar == '\r'))<a name="line.780"></a>
<FONT color="green">781</FONT>                {<a name="line.781"></a>
<FONT color="green">782</FONT>                    if ((aChar == '\r') &amp;&amp; (stringBuffer.charAt(i + 1) == '\n'))<a name="line.782"></a>
<FONT color="green">783</FONT>                    {<a name="line.783"></a>
<FONT color="green">784</FONT>                        stringBuffer.deleteCharAt(i + 1);<a name="line.784"></a>
<FONT color="green">785</FONT>                    }<a name="line.785"></a>
<FONT color="green">786</FONT>                    stringBuffer.setCharAt(i, ' ');<a name="line.786"></a>
<FONT color="green">787</FONT>                }<a name="line.787"></a>
<FONT color="green">788</FONT>            }<a name="line.788"></a>
<FONT color="green">789</FONT>            return stringBuffer.toString();<a name="line.789"></a>
<FONT color="green">790</FONT>    <a name="line.790"></a>
<FONT color="green">791</FONT>            /** ensure [valid_result] Result != null; **/<a name="line.791"></a>
<FONT color="green">792</FONT>        }<a name="line.792"></a>
<FONT color="green">793</FONT>    <a name="line.793"></a>
<FONT color="green">794</FONT>    <a name="line.794"></a>
<FONT color="green">795</FONT>        /**<a name="line.795"></a>
<FONT color="green">796</FONT>         * Exports the data in this table, writing the resulting string to the output stream given.<a name="line.796"></a>
<FONT color="green">797</FONT>         *<a name="line.797"></a>
<FONT color="green">798</FONT>         * @param qualifier EOQualifier to control which rows are exported, or null if all rows are to be exported.<a name="line.798"></a>
<FONT color="green">799</FONT>         * @param sortOrderings NSArray of EOSortOrder to control the order in which rows are exported, or null if no specific order is required.<a name="line.799"></a>
<FONT color="green">800</FONT>         * @param stream the stream to write the data to.  The stream is &lt;em&gt;not&lt;/em&gt; closed at the end of this method - you'll have to do it yourself<a name="line.800"></a>
<FONT color="green">801</FONT>         * @param sender an arbitrary object that is used as a parameter to Column's exportValue() method<a name="line.801"></a>
<FONT color="green">802</FONT>         * @param columnsToExport an ordered list of column names that we will export.  The first name in this array cooresponds to the first field in the data file, the second name to the second field, and so on<a name="line.802"></a>
<FONT color="green">803</FONT>         * @param delimiter the character to use as the delimiter<a name="line.803"></a>
<FONT color="green">804</FONT>         * @param writeHeaderLine should we write the header line, which will contain the names of the columns we are exporting<a name="line.804"></a>
<FONT color="green">805</FONT>         */<a name="line.805"></a>
<FONT color="green">806</FONT>        public void exportTable(EOQualifier qualifier,<a name="line.806"></a>
<FONT color="green">807</FONT>                                NSArray sortOrderings,<a name="line.807"></a>
<FONT color="green">808</FONT>                                OutputStream stream,<a name="line.808"></a>
<FONT color="green">809</FONT>                                Object sender,<a name="line.809"></a>
<FONT color="green">810</FONT>                                NSArray columnsToExport,<a name="line.810"></a>
<FONT color="green">811</FONT>                                String delimiter,<a name="line.811"></a>
<FONT color="green">812</FONT>                                boolean writeHeaderLine)<a name="line.812"></a>
<FONT color="green">813</FONT>            throws IOException<a name="line.813"></a>
<FONT color="green">814</FONT>        {<a name="line.814"></a>
<FONT color="green">815</FONT>            /** require<a name="line.815"></a>
<FONT color="green">816</FONT>            [valid_stream_param] stream != null;<a name="line.816"></a>
<FONT color="green">817</FONT>            [valid_columnsToExport_param] columnsToExport != null;<a name="line.817"></a>
<FONT color="green">818</FONT>            [valid_delimiter_param] delimiter != null;<a name="line.818"></a>
<FONT color="green">819</FONT>            [column_types_can_be_exported] true; **/<a name="line.819"></a>
<FONT color="green">820</FONT>    <a name="line.820"></a>
<FONT color="green">821</FONT>            final char quoteCharacter = '"';<a name="line.821"></a>
<FONT color="green">822</FONT>    <a name="line.822"></a>
<FONT color="green">823</FONT>            // Set a string encoding that will handle odd characters.  Without this, text such as<a name="line.823"></a>
<FONT color="green">824</FONT>            // . . . il ne rsulte pas de linstruction . . . que les craintes de lintresse puissent etre regardes comme fondes. II(K)<a name="line.824"></a>
<FONT color="green">825</FONT>            // Will get exported as<a name="line.825"></a>
<FONT color="green">826</FONT>            // ?. . . il ne r?esulte pas de l?instruction . . . que les craintes de l?int?eress?ee puissent etre regard?ees comme fond?ees.? II(K)<a name="line.826"></a>
<FONT color="green">827</FONT>            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(stream, STRING_ENCODING));<a name="line.827"></a>
<FONT color="green">828</FONT>    <a name="line.828"></a>
<FONT color="green">829</FONT>            if (writeHeaderLine)<a name="line.829"></a>
<FONT color="green">830</FONT>            {<a name="line.830"></a>
<FONT color="green">831</FONT>                NSMutableArray dataValues = new NSMutableArray();<a name="line.831"></a>
<FONT color="green">832</FONT>                Enumeration columnsToExportEnumerator = columnsToExport.objectEnumerator();<a name="line.832"></a>
<FONT color="green">833</FONT>                while (columnsToExportEnumerator.hasMoreElements())<a name="line.833"></a>
<FONT color="green">834</FONT>                {<a name="line.834"></a>
<FONT color="green">835</FONT>                    VirtualColumn column = (VirtualColumn)columnsToExportEnumerator.nextElement();<a name="line.835"></a>
<FONT color="green">836</FONT>                    String columnName = column.name();<a name="line.836"></a>
<FONT color="green">837</FONT>    <a name="line.837"></a>
<FONT color="green">838</FONT>                    // Quote the column name if it has the delimiter string inside or starts with the quote character<a name="line.838"></a>
<FONT color="green">839</FONT>                    if ( (columnName.length() &gt; 0) &amp;&amp;<a name="line.839"></a>
<FONT color="green">840</FONT>                         ((columnName.indexOf(delimiter) != -1) || (columnName.charAt(0) == quoteCharacter)) )<a name="line.840"></a>
<FONT color="green">841</FONT>                    {<a name="line.841"></a>
<FONT color="green">842</FONT>                        // Need to escape the quotes if they are there<a name="line.842"></a>
<FONT color="green">843</FONT>                        columnName = quoteCharacter + StringAdditions.escape(columnName, quoteCharacter, quoteCharacter) + quoteCharacter;<a name="line.843"></a>
<FONT color="green">844</FONT>                    }<a name="line.844"></a>
<FONT color="green">845</FONT>    <a name="line.845"></a>
<FONT color="green">846</FONT>                    dataValues.addObject(columnName);<a name="line.846"></a>
<FONT color="green">847</FONT>                }<a name="line.847"></a>
<FONT color="green">848</FONT>    <a name="line.848"></a>
<FONT color="green">849</FONT>                String dataString = dataValues.componentsJoinedByString(delimiter);<a name="line.849"></a>
<FONT color="green">850</FONT>                writer.write(dataString);<a name="line.850"></a>
<FONT color="green">851</FONT>    <a name="line.851"></a>
<FONT color="green">852</FONT>                // Use \n instead of newLine() so that outout is consistent across<a name="line.852"></a>
<FONT color="green">853</FONT>                // all platforms.<a name="line.853"></a>
<FONT color="green">854</FONT>                writer.write('\n');<a name="line.854"></a>
<FONT color="green">855</FONT>            }<a name="line.855"></a>
<FONT color="green">856</FONT>    <a name="line.856"></a>
<FONT color="green">857</FONT>            // Select and sort rows to export.<a name="line.857"></a>
<FONT color="green">858</FONT>            NSMutableArray rowsToExport = new NSMutableArray(objectsWithQualifier(qualifier));<a name="line.858"></a>
<FONT color="green">859</FONT>            if (sortOrderings != null)<a name="line.859"></a>
<FONT color="green">860</FONT>            {<a name="line.860"></a>
<FONT color="green">861</FONT>                EOSortOrdering.sortArrayUsingKeyOrderArray(rowsToExport, sortOrderings);<a name="line.861"></a>
<FONT color="green">862</FONT>            }<a name="line.862"></a>
<FONT color="green">863</FONT>    <a name="line.863"></a>
<FONT color="green">864</FONT>            try<a name="line.864"></a>
<FONT color="green">865</FONT>            {<a name="line.865"></a>
<FONT color="green">866</FONT>                Enumeration rowEnumerator = rowsToExport.objectEnumerator();<a name="line.866"></a>
<FONT color="green">867</FONT>                while (rowEnumerator.hasMoreElements())<a name="line.867"></a>
<FONT color="green">868</FONT>                {<a name="line.868"></a>
<FONT color="green">869</FONT>                    VirtualRow row = (VirtualRow)rowEnumerator.nextElement();<a name="line.869"></a>
<FONT color="green">870</FONT>                    NSMutableArray dataValues = new NSMutableArray();<a name="line.870"></a>
<FONT color="green">871</FONT>                    Enumeration columnsToExportEnumerator = columnsToExport.objectEnumerator();<a name="line.871"></a>
<FONT color="green">872</FONT>                    VirtualColumn column;<a name="line.872"></a>
<FONT color="green">873</FONT>                    Object fieldValue;<a name="line.873"></a>
<FONT color="green">874</FONT>                    while (columnsToExportEnumerator.hasMoreElements())<a name="line.874"></a>
<FONT color="green">875</FONT>                    {<a name="line.875"></a>
<FONT color="green">876</FONT>                        column = (VirtualColumn)columnsToExportEnumerator.nextElement();<a name="line.876"></a>
<FONT color="green">877</FONT>                        fieldValue = row.exportValueForFieldNamed(column.name(), sender);<a name="line.877"></a>
<FONT color="green">878</FONT>    <a name="line.878"></a>
<FONT color="green">879</FONT>                        if (fieldValue == null)<a name="line.879"></a>
<FONT color="green">880</FONT>                        {<a name="line.880"></a>
<FONT color="green">881</FONT>                            fieldValue = new String();<a name="line.881"></a>
<FONT color="green">882</FONT>                        }<a name="line.882"></a>
<FONT color="green">883</FONT>    <a name="line.883"></a>
<FONT color="green">884</FONT>                        String stringFieldValue = mungeEOLCharacters(fieldValue.toString());<a name="line.884"></a>
<FONT color="green">885</FONT>    <a name="line.885"></a>
<FONT color="green">886</FONT>                        // Quote the string if it has the delimiter string inside or starts with the quote character<a name="line.886"></a>
<FONT color="green">887</FONT>                        if ( (stringFieldValue.length() &gt; 0) &amp;&amp;<a name="line.887"></a>
<FONT color="green">888</FONT>                             ((stringFieldValue.indexOf(delimiter) != -1) || (stringFieldValue.charAt(0) == quoteCharacter)) )<a name="line.888"></a>
<FONT color="green">889</FONT>                        {<a name="line.889"></a>
<FONT color="green">890</FONT>                            // Need to escape the quotes if they are there<a name="line.890"></a>
<FONT color="green">891</FONT>                            stringFieldValue = quoteCharacter + StringAdditions.escape(stringFieldValue, quoteCharacter, quoteCharacter) + quoteCharacter;<a name="line.891"></a>
<FONT color="green">892</FONT>                        }<a name="line.892"></a>
<FONT color="green">893</FONT>    <a name="line.893"></a>
<FONT color="green">894</FONT>                        dataValues.addObject(stringFieldValue);<a name="line.894"></a>
<FONT color="green">895</FONT>                    }<a name="line.895"></a>
<FONT color="green">896</FONT>    <a name="line.896"></a>
<FONT color="green">897</FONT>                    String dataString = dataValues.componentsJoinedByString(delimiter);<a name="line.897"></a>
<FONT color="green">898</FONT>                    writer.write(dataString);<a name="line.898"></a>
<FONT color="green">899</FONT>    <a name="line.899"></a>
<FONT color="green">900</FONT>                    // Use \n instead of newLine() so that outout is consistent across<a name="line.900"></a>
<FONT color="green">901</FONT>                    // all platforms.<a name="line.901"></a>
<FONT color="green">902</FONT>                    writer.write('\n');<a name="line.902"></a>
<FONT color="green">903</FONT>                }<a name="line.903"></a>
<FONT color="green">904</FONT>            }<a name="line.904"></a>
<FONT color="green">905</FONT>            catch (UnsupportedEncodingException e) { /* Not very likely is it? */  }<a name="line.905"></a>
<FONT color="green">906</FONT>    <a name="line.906"></a>
<FONT color="green">907</FONT>            writer.flush();<a name="line.907"></a>
<FONT color="green">908</FONT>        }<a name="line.908"></a>
<FONT color="green">909</FONT>    <a name="line.909"></a>
<FONT color="green">910</FONT>    <a name="line.910"></a>
<FONT color="green">911</FONT>    <a name="line.911"></a>
<FONT color="green">912</FONT>    }<a name="line.912"></a>




























































</PRE>
</BODY>
</HTML>
